---
title: "레디스 콜렉션(작성중)"
tags:
  - NoSQL
  - database
  - redis
  - nodejs
categories:
  - database
last_modified_at: 2020-11-16T13:00:00+18:00
toc: true
---
<script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

# 이번 포스트에서는..

저번 포스트에서는 기본적인 데이터 타입을 설명했다. 이번 포스트에선 한발 더 나아가 `Set`, `Sorted Set`, `Bitmap`, `Hyperloglog` 데이터 타입을 살펴보려 한다.

이 글은 [레디스 기본 데이터 타입](/database/redis_00) 포스트와 이어집니다.

## Sets

셋은 스트링과는 구분되는 순서가 없는 콜렉션이다. 중복되는 원소를 셋에 집어넣을수 없으며 내부적으로 해쉬테이블처럼 구현됐다. 이러한 이유는 최적화 때문인데, 멤버 추가, 삭제, 서치 등의 시간이 $$O(1)$$에 실행되기 때문이다.

셋의 메모리 footprint?는 모든 멤버가 정수일 경우 줄일 수 있다. 멤버 최종 수는 `set-max-inset-entries`에 의존하며 이는 챕터 4에서 추후 설명하겠다.

원소 개수는 $$2^32 -1$$이며 40억개 저장 가능하다.

아래는 `Sets`의 사용 사례다.
- 데이터 필터링: 예를들어 특정 도시에서 출발하여 다른 도시에 도착하는 지정된 항공편을 필터링 할 수 있다.
- 데이터 그루핑: 비슷한 제품을 본 모든 사용자를 그룹핑(아마존의 추천 시스템)
- 멤버쉽 체킹: 블랙리스트에 존재하는지를 확인.

### SADD

`SADD`는 하나 혹은 그 이상의 멤버를 추가하기 위한 커맨드다. 만약 추가하려는 멤버가 존재할 경우 이를 기각하고, 추가된 멤버 수를 리턴한다.

```
$ redis-cli
127.0.0.1:6379> SADD user:max:favorite_artists "Arcade Fire" "Arctic Monkeys"
"Belle & Sebastian" "Lenine"
(integer) 4
127.0.0.1:6379> SADD user:hugo:favorite_artists "Daft Punk" "The Kooks" "Arctic
Monkeys"
(integer) 3
```

### SINTER
`SINTER` 커맨드는 하나 혹은 그 이상의 셋을 받고, 모든 셋에 공통적으로 존재하는 멤버를 배열로 리턴한다.

아래 예제는 Hugo와 Max가 공통적으로 좋아하는 아티스트를 보여준다.

```
127.0.0.1:6379> SINTER user:max:favorite_artists user:hugo:favorite_artists
1) "Arctic Monkeys"
```

### SDIFF
`SDIFF` 커맨드는 하나 혹은 그 이상의 셋을 받는다. 뒤에 따라오는 셋에 존재하지 않는 모든 멤버를 리턴한다. 이 커맨드는 키 네임의 순서가 중요하다. 존재하지 않는 모든 키는 빈 집합으로 간주된다.

```
127.0.0.1:6379> SDIFF user:max:favorite_artists user:hugo:favorite_artists
1) "Belle & Sebastian"
2) "Arcade Fire"
3) "Lenine"
```

두 번째 예제는 `user:max:favorite_artists`의 존재하지 않는 `user:hugo:favorite_artists`의 멤버를 모두 리턴한다.

```
127.0.0.1:6379> SDIFF user:hugo:favorite_artists user:max:favorite_artists
1) "Daft Punk"
2) "The Kooks"
```

### SUNION

`SUNION` 커맨드는 하나 혹은 그 이상의 셋을 받는다. 모든 셋의 모든 멤버를 리턴한다. 중복되는 멤버는 한 번만 보여준다.

```
127.0.0.1:6379> SUNION user:max:favorite_artists user:hugo:favorite_artists
1) "Lenine"
2) "Daft Punk"
3) "Belle & Sebastian"
4) "Arctic Monkeys"
5) "Arcade Fire"
6) "The Kooks"
```

### SPANDMEMBER

`SPNADMEMBER`는 주어진 셋에 랜덤한 멤버를 리턴한다. 셋은 순서가 없기 때문에 위치 인덱스 값으로 반환할 수 없다.

```
127.0.0.1:6379> SRANDMEMBER user:max:favorite_artists
"Arcade Fire"
127.0.0.1:6379> SRANDMEMBER user:max:favorite_artists
"Lenine"
```

### SISMEMBER, SREM, SCARD, SMEMBERS

`SISMEMBER`는 멤버가 셋 안에 존재하는지 확인한다. 존재할 경우에는 1, 아닐 경우에는 0을 리턴한다.

`SISMEMBERS`는 셋에 존재하는 모든 멤버를 리턴한다.

`SREM`은 멤버를 셋에서 삭제하고 인티저 값을 리턴한다.

`SCARD`는 멤버의 수를 리턴한다.

```
127.0.0.1:6379> SISMEMBER user:max:favorite_artists "Arctic Monkeys"
(integer) 1
127.0.0.1:6379> SREM user:max:favorite_artists "Arctic Monkeys"
(integer) 1
127.0.0.1:6379> SISMEMBER user:max:favorite_artists "Arctic Monkeys"
(integer) 0
127.0.0.1:6379> SCARD user:max:favorite_artists
(integer) 3
127.0.0.1:6379> SMEMBERS user:max:favorite_artists
1) "Belle & Sebastian"
2) "Arcade Fire"
3) "Lenine"
```

## Sorted Sets

`Sorted Set` 은 `Set`과 매우 흡사하다. 하지만 각 멤버들이 연관된 스코어를 가지고 있다. 다른 말로 하자면, `Sorted Set`은 중복된 멤버를 가지지 않고, 스코어에의해서 정렬된 `Strings`다. 스코어는 중복될 수 있다. 이러한 경우에는 `lexicographically`하게 정렬한다.

`Sorted Set` 작업은 매우 빠르지만 `Set`의 작업보단 빠르지 않다. 추가, 삭제 갱신은 $$O(logN)$$이 걸린다. 내부적으로 `Sorted Set`은 두 개의 자료구조로 나뉘어져 있다.

- `skip list with hash table` 스킵 리스트는 정렬된 원소 시퀀스를 빠르게 탐색하기 위한 자료구조다.
- `zset-max-ziplist-entries` 과 `zset-max-ziplist-value`에 기반한 `ziplist` 이는 챕터 4에서 다루도록 한다.

아래는 `Sorted Set`의 사용사례다.

- 웨이팅 리스트
- 온라인 게임과 같은 곳에 리더보드
- 자동완성 시스템

### ZADD
`ZADD`는 하나 혹은 그 이상 멤버를 `Sorted Set`에 추가한다. 이미 `Sorted Set`에 존재하는 멤버일 경우에는 요청을 무시한다. 추가된 멤버를 정수 값으로 반환한다.

```
$ redis-cli
127.0.0.1:6379> ZADD leaders 100 "Alice"
(integer) 1
127.0.0.1:6379> ZADD leaders 100 "Zed"
(integer) 1
127.0.0.1:6379> ZADD leaders 102 "Hugo"
(integer) 1
127.0.0.1:6379> ZADD leaders 101 "Max"
(integer) 1
```

`Sorted Set`에 멤버는 스코어와 문자열로 추가된다. 앞에서도 설명했듯이 두가지 정렬 기준이 존재하는데, 스코어 순으로 정렬하며, 만약 스코어가 같을 경우에는 멤버의 문자열 값을 `lexicographically`하게 정렬한다. 앞 예제에서는 `Alice`와 `Zed`가 같은 스코어를 가지기 때문에, 알파벳 순으로 정렬된다.

### ZRANGE, ZREVRANGE ~ WITHSCORES

`ZRANGE`는 주어진 범위에 해당되는 멤버를 출력하며, 오름차순으로 출력한다.

`ZREVRANGE`는 주어진 범위에 해당되는 멤버를 출력하며, 내림차순으로 출력한다.

위 두 커맨드에 `WITHSCORES`를 옵션 파라미터로 줄 수 있으며, 스코어를 같이 출력하게 된다.

```
127.0.0.1:6379> ZREVRANGE leaders 0 -1 WITHSCORES
1) "Hugo"
2) "102"
3) "Max"
4) "101"
5) "Zed"
6) "100"
7) "Alice"
8) "100"
```

```
127.0.0.1:6379> ZREVRANGE leaders 0 -1
1) "Hugo"
2) "Max"
3) "Zed"
4) "Alice"
```

### ZREM

`ZREM`은 멤버를 지운다.

```
127.0.0.1:6379> ZREM leaders "Hugo"
(integer) 1
127.0.0.1:6379> ZREVRANGE leaders 0 -1
1) "Max"
2) "Zed"
3) "Alice"
```

### ZSCORE, ZRANK, ZREVRANK

`ZSCORE`는 특정 멤버에 스코어를 반환한다.

`ZRANK`는 특정 멤버에 랭크(인덱스)를 반환한다.

`ZREVRANK` 는 특정 멤버에 랭크를 `high to low` 방향에서 인덱스를 반환한다.

```
127.0.0.1:6379> ZSCORE leaders "Max"
"101"
127.0.0.1:6379> ZRANK leaders "Max"
(integer) 2
127.0.0.1:6379> ZREVRANK leaders "Max"
(integer) 0
```

## Bitmap
비트맵이 실제 데이터 타입은 아니고, 스트링이다. 스트링에 비트 오퍼레이션을 진행하기 위해 만들어진 데이터 타입이라 볼 수 있다. 레디스에선 이를 조작할 수 있는 커맨드들을 제공하기에 데이터 타입으로 취급한다.

`Bitmap`은 0과 1을 저장할 수 있는 비트 시퀀스이다. 레디스 공식 문서에서 비트맵에 인덱스는 `offset`으로 불린다.

><font size="6">Refernce</font>
- Maxwell Dayvson Da Silva, Redis Essentials
