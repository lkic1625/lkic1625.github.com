<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ford-fulkerson | Hammer&#39;s Blog</title>
<meta name="title" content="ford-fulkerson" />
<meta name="description" content="network flow
flow network란
그래프 이론에서 flow network란 각각의 edge가 capacity을 가지고 있고 flow를 전달하는 Directed Graph이다.
네트워크는 graph이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 subset이다.
이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.
$$WLOG$$
if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$
if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0
서로 다른 노드 source $$s$$와 sink $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 flow network라 한다.
" />
<meta name="keywords" content="algorithm," />


<meta property="og:url" content="http://localhost:1313/ford-fulkerson/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="ford-fulkerson">
  <meta property="og:description" content="network flow flow network란 그래프 이론에서 flow network란 각각의 edge가 capacity을 가지고 있고 flow를 전달하는 Directed Graph이다.
네트워크는 graph이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 subset이다. 이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.
$$WLOG$$
if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$
if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0
서로 다른 노드 source $$s$$와 sink $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 flow network라 한다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2020-08-13T13:00:00+17:00">
    <meta property="article:modified_time" content="2020-08-13T13:00:00+17:00">
    <meta property="article:tag" content="Algorithm">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="ford-fulkerson">
  <meta name="twitter:description" content="network flow flow network란 그래프 이론에서 flow network란 각각의 edge가 capacity을 가지고 있고 flow를 전달하는 Directed Graph이다.
네트워크는 graph이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 subset이다. 이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.
$$WLOG$$
if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$
if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0
서로 다른 노드 source $$s$$와 sink $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 flow network라 한다.">




  <meta itemprop="name" content="ford-fulkerson">
  <meta itemprop="description" content="network flow flow network란 그래프 이론에서 flow network란 각각의 edge가 capacity을 가지고 있고 flow를 전달하는 Directed Graph이다.
네트워크는 graph이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 subset이다. 이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.
$$WLOG$$
if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$
if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0
서로 다른 노드 source $$s$$와 sink $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 flow network라 한다.">
  <meta itemprop="datePublished" content="2020-08-13T13:00:00+17:00">
  <meta itemprop="dateModified" content="2020-08-13T13:00:00+17:00">
  <meta itemprop="wordCount" content="1161">
  <meta itemprop="keywords" content="Algorithm">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>ford-fulkerson</h1>
<p>
  <i>
    <time datetime='2020-08-13'>
      13 Aug, 2020
    </time>
  </i>
</p>

<content>
  <h1 id="network-flow">network flow</h1>
<h2 id="flow-network란">flow network란</h2>
<p>그래프 이론에서 <code>flow network</code>란 각각의 <code>edge</code>가 <code>capacity</code>을 가지고 있고 <code>flow</code>를 전달하는 <code>Directed Graph</code>이다.</p>
<p>네트워크는 <code>graph</code>이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 <code>subset</code>이다.
이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.</p>
<p><a href="https://en.wikipedia.org/wiki/Without_loss_of_generality">$$WLOG$$</a><br>
if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$<br>
if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0</p>
<p>서로 다른 노드 <code>source</code> $$s$$와 <code>sink</code> $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 <code>flow network</code>라 한다.
<img src="%5Cassets%5Cimages%5CNetwork_Flow.svg.png" alt="이미지1"></p>
<h2 id="유량-네트워크-성질">유량 네트워크 성질</h2>
<p>$$Def$$ of flow network</p>
<ul>
<li>$$f(u, v)$$: u, v로 흐르는 실제 유량이다.<br></li>
<li>$$c(u, v)$$: u, v로 흐를 수 있는 용량이다.<br></li>
</ul>
<p>$$Thm$$ of flow network</p>
<ul>
<li>(용량 제한 속성) $$f(u, v) \leq c(u, v)$$:
가장 자명한 속성으로, 각 간선의 유량은 해당 간선의 용량을 초과할 수 없다.</li>
<li>(유량 대칭성)  $$f(u, v) = -f(v, u)$$:
$$v$$로 유량이 흘러올 경우 $$v$$의 입장에서는 음수의 유량을 보내는 것이라 생각하자.</li>
<li>(유량 보존)  $$\Sigma f(u,v) = 0$$:
유량의 대칭성으로 의해 들어오는 유량과 나가는 유량을 합하면 결국 0이 되어야 한다.</li>
</ul>
<h2 id="ford-fulkerson-algorithm">ford-fulkerson Algorithm</h2>
<p><a href="https://en.wikipedia.org/wiki/Maximum_flow_problem"><code>maximum flow problem</code></a>은 <code>flow netwrok</code>에서 얻을 수 있는 가장 큰 유량을 구하는 문제이다. 이를 해결하기 위해 가장 간단한 알고리즘인 <code>ford-fulkerson</code> 알고리즘에 대해 알아보자.
최초로 고안된 네트워크 유량 알고리즘으로 비교적 개념이 간단하다.</p>
<ol>
<li>
<p>유량 네트워크 간선의 유량을 모두 0으로 설정 후 소스에서 싱크로 더 보낼 수 있는 경로를 찾아 보내기를 반복한다.
유량을 보내는 경로를 증가 경로(<code>augmenting path</code>)라 한다.</p>
</li>
<li>
<p>증가 경로이려면 흐르고 있는 유량을 제외하더라도 여유 용량이 존재해야 한다.
이를 잔여 용량(<code>residual capacity</code>)라 하며,<br><br>
$$r: V$$ x $$V → ℝ∞$$<br> $$r(u, v) = c(u, v) - f(u, v)$$<br><br>
로 정의하자. 흘려 보낼 수 있는 유량의 최대량은 포함된 간선의 잔여 용량 중 최소값으로 정의된다.</p>
</li>
</ol>
<p>단순히 위 속성만으로는 알고리즘이 항상 최대 유량을 얻는다는 것은 의문점이 들 것이다. 여기서 <code>ford-fulkerson</code> 알고리즘의 핵심이 되는 아이디어는 유량의 대칭성을 이용한 접근법이다.</p>
<p><img src="%5Cassets%5Cimages%5Cford-fulkerson-example-01.png" alt="이미지2"></p>
<p>if $$f(A, B) = 1$$ then $$f(B, A) = -1$$ <br>
$$\rightarrow r(B, A) = c(B, A) - f(B, A) = 0 + (-1) = 1$$<br><br>
위 과정은 실제로 존재하지 않는 간선 $$(B, A)$$에 대해 용량의 1만큼의 유량을 더 보낼 수 있다는 의미이다. 특정 방향으로 보내는 유량을 줄이는 것은 그 반대쪽에서 유량을 보내주는 것과 같은 효과를 내기 때문이다. 따라서, 기존 유량을 상쇄하는 방향으로 증가 경로를 건설하고, 탐색 알고리즘을 진행한다면, 우리가 원하는 최대 유량을 찾을 수 있는 것이다.</p>
<h2 id="정당성-증명">정당성 증명</h2>
<blockquote>
<p>링크 참조<br>
<a href="../proof_of_correctness_ford_fulkerson">포드 풀커슨 알고리즘 정당성 증명</a></p></blockquote>
<h2 id="구현-및-코드">구현 및 코드</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000">//source code for praticing ford-fulkerson Algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;queue&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX_V = 100;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> V;
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> capacity[MAX_V + 1][MAX_V + 1], flow[MAX_V][MAX_V];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> FordFulkerson (<span style="color:#2b91af">int</span> source, <span style="color:#2b91af">int</span> sink) {
</span></span><span style="display:flex;"><span>	memset(flow, 0, <span style="color:#00f">sizeof</span>(flow));
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> totalFlow = 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (true) {
</span></span><span style="display:flex;"><span>		vector&lt;<span style="color:#2b91af">int</span>&gt; parent(MAX_V + 1, -1);
</span></span><span style="display:flex;"><span>		queue&lt;<span style="color:#2b91af">int</span>&gt; q;
</span></span><span style="display:flex;"><span>		parent[source] = source;
</span></span><span style="display:flex;"><span>		q.push(source);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">while</span> (!q.empty()) {
</span></span><span style="display:flex;"><span>			<span style="color:#2b91af">int</span> here = q.front(); q.pop();
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> there = 0; there &lt; V; there++) {
</span></span><span style="display:flex;"><span>				<span style="color:#00f">if</span> (capacity[here][there] - flow[here][there] &gt; 0
</span></span><span style="display:flex;"><span>					&amp;&amp; parent[there] == -1) {
</span></span><span style="display:flex;"><span>					q.push(there);
</span></span><span style="display:flex;"><span>					parent[there] = here;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (parent[sink] == -1) <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> amount = 123123123;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> p = sink; p != source; p = parent[p]) {
</span></span><span style="display:flex;"><span>			amount = min(amount, capacity[parent[p]][p] - flow[parent[p]][p]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> p = sink; p != source; p = parent[p]) {
</span></span><span style="display:flex;"><span>			flow[parent[p]][p] += amount;
</span></span><span style="display:flex;"><span>			flow[p][parent[p]] -= amount;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		totalFlow += amount;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> totalFlow;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="응용-및-문제">응용 및 문제</h2>
<p>승부조작, <a href="https://www.algospot.com/judge/problem/read/MATCHFIX/">https://www.algospot.com/judge/problem/read/MATCHFIX/</a>, ALGOSPOT</p>
<p>예제 입력</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-3" data-lang="3"><span style="display:flex;"><span>2 2
</span></span><span style="display:flex;"><span>3 3
</span></span><span style="display:flex;"><span>0 1
</span></span><span style="display:flex;"><span>0 1
</span></span><span style="display:flex;"><span>3 3
</span></span><span style="display:flex;"><span>4 2 2
</span></span><span style="display:flex;"><span>1 2
</span></span><span style="display:flex;"><span>1 2
</span></span><span style="display:flex;"><span>1 2
</span></span><span style="display:flex;"><span>4 4
</span></span><span style="display:flex;"><span>5 3 3 2
</span></span><span style="display:flex;"><span>0 1
</span></span><span style="display:flex;"><span>1 2
</span></span><span style="display:flex;"><span>2 3
</span></span><span style="display:flex;"><span>1 3
</span></span></code></pre></div><p>예제 출력</p>
<pre tabindex="0"><code>5
-1
5
</code></pre><p>구현 코드</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#008000">/*
</span></span></span><span style="display:flex;"><span><span style="color:#008000">https://www.algospot.com/judge/problem/read/MATCHFIX\
</span></span></span><span style="display:flex;"><span><span style="color:#008000">
</span></span></span><span style="display:flex;"><span><span style="color:#008000">networkFlow, bellmanFord Algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#008000">
</span></span></span><span style="display:flex;"><span><span style="color:#008000">input
</span></span></span><span style="display:flex;"><span><span style="color:#008000">입력의 첫 줄에는 테스트 케이스의 수 C (C &lt;= 50) 가 주어집니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">각 테스트 케이스의 첫 줄에는 결승 리그에 참가하는 선수의 수 N (2 &lt;= N &lt;= 12) 과 남아 있는 경기의 수 M (0 &lt;= M &lt;= 100) 이 주어집니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">이 때 각 선수에게는 0부터 N-1 까지의 번호가 주어집니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">그 다음 줄에는 N 개의 정수로 0번부터 N-1 번까지 순서대로 각 선수의 현재 승수가 주어집니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">그 후 M 줄에는 각 경기를 치르는 두 선수의 번호가 주어집니다. 모든 선수의 현재 승수는 1000 이하입니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">
</span></span></span><span style="display:flex;"><span><span style="color:#008000">output
</span></span></span><span style="display:flex;"><span><span style="color:#008000">각 테스트 케이스마다 한 줄에 X가 리그를 단독 우승하기 위해 필요한 최소 승수를 출력합니다. 만약 이것이 불가능하다면 -1 을 출력합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">
</span></span></span><span style="display:flex;"><span><span style="color:#008000">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;tuple&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;string.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;queue&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX_N = 12, MAX_M = 100, PLAYER_X = 0, SIZE = MAX_N + MAX_M, SOURCE = SIZE,  SINK = SIZE + 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> C, N, M, input, u, v;
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> wins[MAX_N + 2], capacity[SIZE + 2][SIZE + 2], flow[SIZE + 2][SIZE + 2];
</span></span><span style="display:flex;"><span>pair&lt;<span style="color:#2b91af">int</span>, <span style="color:#2b91af">int</span>&gt; match[MAX_M];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> FordFulkerson(<span style="color:#2b91af">int</span> source, <span style="color:#2b91af">int</span> sink) {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//init flow edge
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	memset(flow, 0, <span style="color:#00f">sizeof</span>(flow));
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> totalFlow = 0;
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> totalFlow = 0;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (true) {
</span></span><span style="display:flex;"><span>		vector&lt;<span style="color:#2b91af">int</span>&gt; parent(SIZE + 2, -1);
</span></span><span style="display:flex;"><span>		queue&lt;<span style="color:#2b91af">int</span>&gt; q;
</span></span><span style="display:flex;"><span>		parent[source] = source;
</span></span><span style="display:flex;"><span>		q.push(source);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">while</span> (!q.empty()) {
</span></span><span style="display:flex;"><span>			<span style="color:#2b91af">int</span> here = q.front(); q.pop();
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> there = 0; there &lt; SIZE + 2; there++) {
</span></span><span style="display:flex;"><span>				<span style="color:#00f">if</span> (capacity[here][there] - flow[here][there] &gt; 0
</span></span><span style="display:flex;"><span>					&amp;&amp; parent[there] == -1) {<span style="color:#008000">//If there is a node that has not been visited and can flow, push to the queue.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>					q.push(there);
</span></span><span style="display:flex;"><span>					parent[there] = here;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (parent[sink] == -1) <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> amount = MAX_N + 1;
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//finding the minimum amount of flow.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> p = sink; p != source; p = parent[p]) {
</span></span><span style="display:flex;"><span>			amount = min(amount, capacity[parent[p]][p] - flow[parent[p]][p]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//flowing..
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> p = sink; p != source; p = parent[p]) {
</span></span><span style="display:flex;"><span>			flow[parent[p]][p] += amount;
</span></span><span style="display:flex;"><span>			flow[p][parent[p]] -= amount;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		totalFlow += amount;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> totalFlow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> isChampionshipable(<span style="color:#2b91af">int</span> totalWins) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//If there is a Wins greater than totalWins, then return false;
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#00f">if</span> (*max_element(wins  + 1, wins + N) &gt;= totalWins) <span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//init capacity edge
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	memset(capacity, 0, <span style="color:#00f">sizeof</span>(capacity));
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//boundary of Indexing
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#2b91af">int</span> boundary = MAX_N;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; M; i++) {
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> u = match[i].first;
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> v = match[i].second;
</span></span><span style="display:flex;"><span>		capacity[SOURCE][boundary + i] = 1;
</span></span><span style="display:flex;"><span>		capacity[boundary + i][u] = 1;
</span></span><span style="display:flex;"><span>		capacity[boundary + i][v] = 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//If X is to win alone with a w win, the win or loss of the remaining games will be properly determined
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#008000">//and all other players must finish the league with less than w - 1 win.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> node = 0; node &lt; N; node++) {
</span></span><span style="display:flex;"><span>		capacity[node][SINK] = max(totalWins - wins[node] - 1, 0);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	capacity[PLAYER_X][SINK] = totalWins - wins[PLAYER_X];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> FordFulkerson(SOURCE, SINK) == M &amp;&amp; flow[PLAYER_X][SINK] == capacity[PLAYER_X][SINK];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//fast I/O
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//input
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	cin &gt;&gt; C;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (C-- &gt; 0) {
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> totalMatchCountOfX = 0;
</span></span><span style="display:flex;"><span>		cin &gt;&gt; N &gt;&gt; M;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> player = 0; player &lt; N; player++) {
</span></span><span style="display:flex;"><span>			cin &gt;&gt; input;
</span></span><span style="display:flex;"><span>			wins[player] = input;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> game = 0; game &lt; M; game++) {
</span></span><span style="display:flex;"><span>			cin &gt;&gt; u &gt;&gt; v;
</span></span><span style="display:flex;"><span>			match[game] = { u ,v };
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (u == 0 || v == 0) {
</span></span><span style="display:flex;"><span>				totalMatchCountOfX++;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> flag = false, i = 0;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (; i &lt;= totalMatchCountOfX; i++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (isChampionshipable(wins[PLAYER_X] + i)) {
</span></span><span style="display:flex;"><span>				flag = true;
</span></span><span style="display:flex;"><span>				<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span>(flag)
</span></span><span style="display:flex;"><span>			cout &lt;&lt; i + wins[PLAYER_X] &lt;&lt; <span style="color:#a31515">&#34;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>			cout &lt;&lt; -1 &lt;&lt; <span style="color:#a31515">&#34;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><font size="6">Refernce</font></p></blockquote>
<ul>
<li>구종만 지음, 알고리즘 문제 해결 전략, 인사이트, 32장</li>
<li><a href="https://en.wikipedia.org/wiki/Flow_network">https://en.wikipedia.org/wiki/Flow_network</a></li>
</ul>

</content>
<p>
  
  <a href="http://localhost:1313/blog/algorithm/">#Algorithm</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
