<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>dynamic programming | Hammer&#39;s Blog</title>
<meta name="title" content="dynamic programming" />
<meta name="description" content="
chained matrix multiplication
$$input$$: $$d_0, d_1 &hellip; d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$
$$output$$: $$D(i, j) = M_i \times M_{i&#43;1} \times &hellip; \times M_j$$ 의 최소비용
점화식
$$\text{for all i}\in S,  D(i,i) = 0$$
$$D(i, j) = min_{i \le k \le j}(D(i, k) &#43; D(k &#43; 1,j) &#43; d_{i-1} \times d_k \times d_j$$
알고리즘

edit distance
편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.
유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다." />
<meta name="keywords" content="dp,algorithm," />


<meta property="og:url" content="http://localhost:1313/dynamic-programming/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="dynamic programming">
  <meta property="og:description" content="chained matrix multiplication $$input$$: $$d_0, d_1 … d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$
$$output$$: $$D(i, j) = M_i \times M_{i&#43;1} \times … \times M_j$$ 의 최소비용
점화식 $$\text{for all i}\in S, D(i,i) = 0$$ $$D(i, j) = min_{i \le k \le j}(D(i, k) &#43; D(k &#43; 1,j) &#43; d_{i-1} \times d_k \times d_j$$
알고리즘 edit distance 편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.
유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:tag" content="Dp">
    <meta property="article:tag" content="Algorithm">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="dynamic programming">
  <meta name="twitter:description" content="chained matrix multiplication $$input$$: $$d_0, d_1 … d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$
$$output$$: $$D(i, j) = M_i \times M_{i&#43;1} \times … \times M_j$$ 의 최소비용
점화식 $$\text{for all i}\in S, D(i,i) = 0$$ $$D(i, j) = min_{i \le k \le j}(D(i, k) &#43; D(k &#43; 1,j) &#43; d_{i-1} \times d_k \times d_j$$
알고리즘 edit distance 편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.
유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다.">




  <meta itemprop="name" content="dynamic programming">
  <meta itemprop="description" content="chained matrix multiplication $$input$$: $$d_0, d_1 … d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$
$$output$$: $$D(i, j) = M_i \times M_{i&#43;1} \times … \times M_j$$ 의 최소비용
점화식 $$\text{for all i}\in S, D(i,i) = 0$$ $$D(i, j) = min_{i \le k \le j}(D(i, k) &#43; D(k &#43; 1,j) &#43; d_{i-1} \times d_k \times d_j$$
알고리즘 edit distance 편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.
유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다.">
  <meta itemprop="wordCount" content="1176">
  <meta itemprop="keywords" content="Dp,Algorithm">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>dynamic programming</h1>
<p>
  <i>
    <time datetime='0001-01-01'>
      01 Jan, 0001
    </time>
  </i>
</p>

<content>
  <script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<h1 id="chained-matrix-multiplication">chained matrix multiplication</h1>
<p>$$input$$: $$d_0, d_1 &hellip; d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$<br>
$$output$$: $$D(i, j) = M_i \times M_{i+1} \times &hellip; \times M_j$$ 의 최소비용</p>
<h2 id="점화식">점화식</h2>
<p>$$\text{for all i}\in S,  D(i,i) = 0$$
$$D(i, j) = min_{i \le k \le j}(D(i, k) + D(k + 1,j) + d_{i-1} \times d_k \times d_j$$</p>
<h2 id="알고리즘">알고리즘</h2>
<p><img src="/assets/images/matchainmul.PNG" alt="행렬이미지"></p>
<h1 id="edit-distance">edit distance</h1>
<p>편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.</p>
<p>유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다.</p>
<h2 id="점화식-1">점화식</h2>
<p>$$ DP[m][n] =  \begin{cases} DP[m - 1][n - 1]  &amp; \text{if }A[m] == B[n] \ min(DP[m - 1][n], DP[m][n - 1], DP[m - 1][n - 1]) + 1   &amp; else \end{cases} $$</p>
<p>$$A$$ 문자열의 $$m$$번째와 $$B$$ 문자열의 $$n$$번째 까지 문자열의 유사도를 나타내며 $$A[m] == B[n]$$일 경 $$DP[m - 1][n - 1]$$를 그대로 이어 받는다.</p>
<h1 id="floyd-warshall">floyd warshall</h1>
<p>변의 가중치가 음이거나 양인 가중그래프에서(음수 사이클이 없어야 한다.) 최단경로를 찾는 알고리즘이다.</p>
<h2 id="점화식-2">점화식</h2>
<p>알고리즘은 아래 점화식에 기반하여 동작한다.
$$D(k, i, j) = min(D(k - 1, i, k) + D(k - 1, k, j), D(k - 1, i, j))$$</p>
<p>$$D(k, i, j)$$는 $$1 .. k$$ 까지의 정점을 사용하여 $$i$$에서 $$j$$로 갈 수 있는 최단거리를 뜻한다.
점화식에서는 $$k - 1$$까지의 정점을 사용한 후 중간에 $$k$$를 거쳐 최단거리를 구하는 방법과 기존 방법 중 더 최단경로를 선택한다.</p>
<h2 id="알고리즘-1">알고리즘</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">for</span>(<span style="color:#2b91af">int</span> k = 1; k &lt;= N; k++){
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span>(<span style="color:#2b91af">int</span> i = 1; 1 &lt;= N; i++){
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span>(<span style="color:#2b91af">int</span> j = 1; j &lt;= N; j++){
</span></span><span style="display:flex;"><span>      DP[i][j] = min(DP[i][k] + DP[k][j], DP[i][j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>공간 복잡도를 $$O(N^2)$$으로 줄일 수 있는 이유는 $$1 .. k - 1$$의 정점을 사용하여 $$k$$로 가거나 도착하는 방법은 $$1 .. k$$일때도 같기 때문이다.</p>
<h1 id="knapsack-problem">knapsack problem</h1>
<h2 id="문제-정의">문제 정의</h2>
<p>도둑이 보석가게에 배낭을 메고 침입했다.
배낭의 최대 용량은 W이며, 이를 초과해서 보석을 담으면 배낭이 찢어질 것이다.
각 보석들의 무게와 가격은 알고 있다.
배낭이 찢어지지 않는 선에서 가격 합이 최대가 되도록 보석을 담는 방법은?</p>
<p>$$input$$: $$W$$, $$(w_1,v_1), (w_2,v_2) &hellip; ,(w_n,v_n)$$ <br>
$$output$$: the maximum value V less than or equal to W</p>
<h2 id="점화식-3">점화식</h2>
<p>$$
DP[i][w] =  \begin{cases} DP[i - 1][w]  &amp; \text{if }w_i &gt; w \ max(v_i + DP[i-1][w-w_i], DP[i-1][w])   &amp; else \end{cases}
$$</p>
<h1 id="fibonacci">Fibonacci</h1>
<h2 id="점화식-4">점화식</h2>
<p>$$F_n =  \begin{cases} 0  &amp; \text{if }n = 0 \ 1   &amp; \text{if }n = 1 \ F_{n-1} + F_{n-2}   &amp; \text{if }n &gt; 1 \end{cases}$$</p>
<h1 id="알약">알약</h1>
<h2 id="문제-정의-1">문제 정의</h2>
<p>70세 박종수 할아버지는 매일 매일 약 반알을 먹는다. 손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다.</p>
<p>첫째 날에 종수는 병에서 약 하나를 꺼낸다. 그 다음, 그 약을 반으로 쪼개서 한 조각은 먹고, 다른 조각은 다시 병에 넣는다.</p>
<p>다음 날부터 종수는 병에서 약을 하나 꺼낸다. (약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고, 아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다.</p>
<p>종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다. 손녀는 할아버지에게 받은 문자를 종이에 기록해 놓는다. 총 2N일이 지나면 길이가 2N인 문자열이 만들어지게 된다. 이때, 가능한 서로 다른 문자열의 개수는 총 몇 개일까?</p>
<h2 id="점화식-5">점화식</h2>
<p>$$
DP[h][w] =  \begin{cases} 1  &amp; \text{if }h = 0 \ dp[h - 1][w + 1]   &amp; \text{else if }w = 0 \ dp[h - 1][w + 1] + dp[h][w - 1]   &amp; \text{else } \end{cases}
$$</p>
<h2 id="코드">코드</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX = 30 + 1;
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> N, input;
</span></span><span style="display:flex;"><span><span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> dp[MAX][MAX];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//FAST IO
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//DP
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> h = 0; h &lt;= 30; h++) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> w = 0; w &lt;= 30; w++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (h == 0) {
</span></span><span style="display:flex;"><span>				dp[h][w] = 1;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#00f">else</span> <span style="color:#00f">if</span> (w == 0) {
</span></span><span style="display:flex;"><span>				dp[h][w] = dp[h - 1][w + 1];
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>				dp[h][w] = dp[h - 1][w + 1] + dp[h][w - 1];
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (true) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; N;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (N == 0) <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>		cout &lt;&lt; dp[N][0] &lt;&lt; <span style="color:#a31515">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="팰린드롬">팰린드롬?</h1>
<h2 id="문제-정의-2">문제 정의</h2>
<p>명우는 홍준이와 함께 팰린드롬 놀이를 해보려고 한다.</p>
<p>먼저, 홍준이는 자연수 N개를 칠판에 적는다. 그 다음, 명우에게 질문을 총 M번 한다.</p>
<p>각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있으며, S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어보며, 명우는 각 질문에 대해 팰린드롬이다 또는 아니다를 말해야 한다.</p>
<p><a href="https://www.acmicpc.net/problem/10942">https://www.acmicpc.net/problem/10942</a></p>
<h2 id="점화식-6">점화식</h2>
<p><img src="/assets/images/pdrom.png" alt="이미지1"></p>
<h2 id="코드-1">코드</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> dp[2001][2001], N, S, E, M, n[2001];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//FAST IO
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	ios_base::sync_with_stdio(false);
</span></span><span style="display:flex;"><span>	cin.tie(NULL);
</span></span><span style="display:flex;"><span>	cout.tie(NULL);
</span></span><span style="display:flex;"><span>	cin &gt;&gt; N;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; N; i++) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; n[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//dp
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#008000">//It should be noted here that the order in which DP matrices are filled is diagonal,
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  	<span style="color:#008000">//which creates a lower triangulation matrix.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> diff = 0; diff &lt; N; diff++) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> s = 0, e = s + diff; s &lt; N; s++, e++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (s == e) {
</span></span><span style="display:flex;"><span>				dp[s][e] = true;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#00f">else</span> <span style="color:#00f">if</span> (e - s == 1) {
</span></span><span style="display:flex;"><span>				dp[s][e] = (n[e] == n[s]);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>				dp[s][e] = (n[e] == n[s] &amp;&amp; dp[s + 1][e - 1]);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cin &gt;&gt; M;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; M; i++) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; S &gt;&gt; E;
</span></span><span style="display:flex;"><span>		cout &lt;&lt; dp[S - 1][E - 1] &lt;&lt; <span style="color:#a31515">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="고층-빌딩">고층 빌딩</h1>
<h2 id="문제-정의-3">문제 정의</h2>
<p>상근이가 살고있는 동네에는 빌딩 N개가 한 줄로 세워져 있다. 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 같은 높이를 가지는 빌딩은 없다. 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았다.</p>
<p>상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에, 빌딩이 어떤 순서로 위치해있는지는 알 수가 없다.</p>
<p>빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때, 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.</p>
<p>예를 들어, N = 5, L = 3, R = 2인 경우에 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다</p>
<h2 id="점화식-7">점화식</h2>
<p>$$
dp[N][L][R] = ( dp[N - 1][L - 1][R] + dp[N - 1][L][R - 1] + dp[N - 1][L][R] * (N - 2) ) \pmod p;
$$</p>
<h2 id="코드-2">코드</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">#include</span><span style="color:#00f">&lt;iostream&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#define MOD %
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> PRIME = 1000000007, MAX = 100 + 5;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> dp[MAX][MAX][MAX];
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> N, R, L;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> memo(<span style="color:#2b91af">int</span> n, <span style="color:#2b91af">int</span> l, <span style="color:#2b91af">int</span> r) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (l == 0 || r == 0) <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span>&amp; ret = dp[n][l][r];
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (ret != -1) <span style="color:#00f">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> ret = (memo(n - 1, l - 1, r) + memo(n - 1, l, r - 1) + memo(n - 1, l, r) * (n - 2)) MOD PRIME;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cin &gt;&gt; N &gt;&gt; R &gt;&gt; L;
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//Recurrence relation
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#008000">//dp[N][L][R] = dp[N - 1][L - 1][R] + dp[N - 1][L][R - 1] + dp[N - 1][L][R] * (N - 2);
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	dp[1][1][1] = 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> n = 2; n &lt;= N; n++) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> l = n; l &gt; 0; l--) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> r = 1; l + r &lt;= n + 1; r++) {
</span></span><span style="display:flex;"><span>				dp[n][l][r] = dp[n - 1][l - 1][r] + dp[n - 1][l][r - 1] + dp[n - 1][l][r] * (n - 2);
</span></span><span style="display:flex;"><span>				dp[n][l][r] = dp[n][l][r] MOD PRIME;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cout &lt;&lt; dp[N][L][R];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><font size="6">Refernce</font></p></blockquote>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/">https://ko.wikipedia.org/wiki/</a>플로이드-워셜_알고리즘</li>
<li><a href="https://doorbw.tistory.com/50">https://doorbw.tistory.com/50</a></li>
</ul>

</content>
<p>
  
  <a href="http://localhost:1313/blog/dp/">#Dp</a>
  
  <a href="http://localhost:1313/blog/algorithm/">#Algorithm</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
