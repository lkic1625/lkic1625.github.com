<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pollard&#39;s rho algorithm | Hammer&#39;s Blog</title>
<meta name="title" content="Pollard&#39;s rho algorithm" />
<meta name="description" content="
Introduction
이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.
백준에 큰 수 소인수분해 4149 문제 풀이와 함께 진행하겠다.
Core ideas
소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 인수라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 &#43; 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(PRG)할 때 사용된다.
이때 시작값을 적당히 2로 설정하면
$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$
위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 폴라드 로 알고리즘의 핵심 아이디어다." />
<meta name="keywords" content="math,number_theory,prime," />


<meta property="og:url" content="http://localhost:1313/pollards-rho-algorithm/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="Pollard&#39;s rho algorithm">
  <meta property="og:description" content="Introduction 이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.
백준에 큰 수 소인수분해 4149 문제 풀이와 함께 진행하겠다.
Core ideas 소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 인수라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 &#43; 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(PRG)할 때 사용된다.
이때 시작값을 적당히 2로 설정하면
$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$
위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 폴라드 로 알고리즘의 핵심 아이디어다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:tag" content="Math">
    <meta property="article:tag" content="Number_theory">
    <meta property="article:tag" content="Prime">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Pollard&#39;s rho algorithm">
  <meta name="twitter:description" content="Introduction 이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.
백준에 큰 수 소인수분해 4149 문제 풀이와 함께 진행하겠다.
Core ideas 소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 인수라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 &#43; 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(PRG)할 때 사용된다.
이때 시작값을 적당히 2로 설정하면
$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$
위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 폴라드 로 알고리즘의 핵심 아이디어다.">




  <meta itemprop="name" content="Pollard&#39;s rho algorithm">
  <meta itemprop="description" content="Introduction 이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.
백준에 큰 수 소인수분해 4149 문제 풀이와 함께 진행하겠다.
Core ideas 소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 인수라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 &#43; 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(PRG)할 때 사용된다.
이때 시작값을 적당히 2로 설정하면
$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$
위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 폴라드 로 알고리즘의 핵심 아이디어다.">
  <meta itemprop="wordCount" content="1412">
  <meta itemprop="keywords" content="Math,Number_theory,Prime">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>Pollard&#39;s rho algorithm</h1>
<p>
  <i>
    <time datetime='0001-01-01'>
      01 Jan, 0001
    </time>
  </i>
</p>

<content>
  <script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<h1 id="introduction">Introduction</h1>
<p>이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.</p>
<p>백준에 <a href="https://www.acmicpc.net/problem/4149">큰 수 소인수분해 4149</a> 문제 풀이와 함께 진행하겠다.</p>
<h1 id="core-ideas">Core ideas</h1>
<p>소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 <b>인수</b>라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 + 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(<code>PRG</code>)할 때 사용된다.</p>
<p>이때 시작값을 적당히 2로 설정하면</p>
<p>$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$</p>
<p>위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 <code>폴라드 로</code> 알고리즘의 <b>핵심</b> 아이디어다.</p>
<p>이 수열에 나오는 수의 개수는 유한하기 때문에, $$n$$의 나머지 수열 $${x_k}$$와 $${x_k ,mod,p}$$는 언젠가 반복된다. 이 수열을 완전한 난수라고 가정하면 <code>birthday pardox</code>에 의해 이 수열이 반복되기 전까지 나오는 서로 다른 $$x_k$$의 개수는 대략 $$O(\sqrt{n})$$이다. (여기서 $$N$$은 가능한 값의 개수이다.) 따라서, 수열  $${x_k ,mod,p}$$은 수열  $${x_k}$$보다 먼저 반복된다.</p>
<p>각각의 수열을 유향 그래프로 표현한다면 그리스 문자 $$\rho$$와 같이 생겨서 폴라드 로 알고리즘이라 붙인 것이다.</p>
<p><img src="/assets/images/pollards'_rho.png" alt="이미지"></p>
<p>그렇다면, 두 수열의 관계를 어떻게 이용하여 우리는 인수 <code>p</code>를 찾아내는 것일까? 알고리즘은 아래와 같이 동작한다.</p>
<ol>
<li>위 수열에서 나오는 반복을 순환 찾기 알고리즘으로 찾는다.</li>
<li>먼저 두 수 $$x_i$$와 $$x_j$$를 정한다. $$x_i \equiv x_j \pmod p$$를 만족 시 $$p = k(x_i - x_j) ,, k \in \mathbb{N}$$가 성립한다.</li>
<li>$$gcd(x_i - x_j, n)$$이 1이 아니라면 수열 $${x_k ,mod,p}$$는 사이클이 있다는 것을 의미하고, $$x_i - x_j$$이 p의 배수 혹은 0이 되어야한다.</li>
<li>$$gcd(x_i - x_j, n)$$는 결국 $$n$$ 혹은 $$p$$를 값으로 가지게되고, $$p$$를 구할 수 있다.</li>
</ol>
<h1 id="algorithm">Algorithm</h1>
<h2 id="floyds-cycle-detection-algorithm">Floyd&rsquo;s Cycle Detection Algorithm</h2>
<p>우선 수열 $${x_k ,mod,p}$$의 사이클을 찾는 알고리즘은, 플로이드 알고리즘을 통해 구현한다.</p>
<p>이는 <code>Two Pointer</code>를 이용하며, 이 포인터는 서로 다른 속도로 시퀀스를 탐색한다. 매 반복마다, 첫 포인터는 한 칸을 움직이고 두번째 포인터는 두 칸을 움직인다. 만약 사이클 길이가 $$\lambda$$이고 사이클이 시작하는 곳의 첫 인덱스가 $$\mu$$일 경우 시간복잡도는 $$O(\mu + \lambda)$$다.</p>
<blockquote>
<p>This algorithm is also known as tortoise and the hare algorithm, based on the tale in which a tortoise (here a slow pointer) and a hare (here a faster pointer) make a race.</p></blockquote>
<p>플로이드 알고리즘은 재귀적으로 비교하는 두 인자에 진행속도에 차이를 두어 만약 사이클이 존재할 경우 둘이 만날 수 밖에 없도록 하는 것이다.</p>
<h3 id="pseudo-code">pseudo code</h3>
<pre tabindex="0"><code>function floyd(f, x0):
    tortoise = x0
    hare = f(x0)
    while tortoise != hare:
        tortoise = f(tortoise)
        hare = f(f(hare))
    return true
</code></pre><h3 id="implementation">implementation</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (g == n) {
</span></span><span style="display:flex;"><span>    x = y = rand() % n + 1;			
</span></span><span style="display:flex;"><span>    c = rand() % n + 1;
</span></span><span style="display:flex;"><span>    g = 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  x = f(x);
</span></span><span style="display:flex;"><span>  y = f(f(y));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ull sub = x &gt; y ? x - y : y - x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  g = gcd(n, sub);
</span></span><span style="display:flex;"><span>} <span style="color:#00f">while</span> (g == 1);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h2 id="brents-algorithm">Brent&rsquo;s algorithm</h2>
<p><code>__int128_t</code> 타입을 사용하지 않을 경우 곱셈 연산을 매우 느리게 진행해야하는데, 이에 따라 플로이드 알고리즘 만으로는 제한시간 내에 풀기 어려울 수 있어 새로운 알고리즘 도입이 필요했다.</p>
<p>위 알고리즘은 플로이드 알고리즘과 비슷하다. 투 포인터를 사용하지만 $$2^i$$만큼 전진시킨다. $$2^i$$가 $$\mu, \lambda$$보다 크면, 사이클을 찾을 수 있다. 자세한 코드는 최종 코드에서 확인하길 바란다.</p>
<h3 id="pseudo-code-1">pseudo code</h3>
<pre tabindex="0"><code>function floyd(f, x0):
    tortoise = x0
    hare = f(x0)
    l = 1
    while tortoise != hare:
        tortoise = hare
        repeat l times:
            hare = f(hare)
            if tortoise == hare:
                return true
        l *= 2
    return true
</code></pre><h2 id="miller-rabin-primality-test">Miller-Rabin primality test</h2>
<p>여기서 주의해야할 점은 폴라드 로 알고리즘이 소인수가 아닌 <b>인수</b>분해 알고리즘이란 점이다. 즉, 우리가 구한 $$p$$가 소수인지를 빠르게 판단해야 한다. 이는 밀러라빈 소수 판정법을 통해 구현해야 한다.</p>
<p>밀러-라빈 소수 판정법은 확률적 판별 알고리즘이다. 페르마 테스트와 더불어 몇 개의 인자를 넣어 확률적으로 아닌지를 판단해야한다.</p>
<h3 id="lemma">Lemma</h3>
<p>알고리즘 설명 전에 우선 보조정리부터 소개하겠다.</p>
<blockquote>
<p>소수 $$p$$에 대해 $$x^2 \equiv \pmod p$$이면 $$x \equiv 1 \pmod p$$ 거나 $$x \equiv -1 \pmod p$$이다.</p></blockquote>
<p>$$Proof$$: 합동식 정의에서 $$x^2-1 = (x+1)(x-1)$$은 $$p$$의 배수이고, $$x+1$$과 $$x-1$$ 둘 중 하나는 $$p$$의 배수여야한다.</p>
<p>여기서 수학적 직관이 어느정도 있는 사람이라면, 과연 위 합동식이 해를 두 개만 가지는지에 대해 의문을 들 수 있다. 먼저 정답을 말하자면 그렇다. 우리는 좀 더 일반적인 상황에서 아래와 같은 증명도 가능하다!</p>
<blockquote>
<p>$$\mathbb{Z}_p$$ 상에서 다항식 차수로 $$n$$을 가지는 $$f(x)$$는 최대 $$n$$개의 해를 가진다.</p></blockquote>
<p>이 증명은 <a href="https://crypto.stanford.edu/pbc/notes/numbertheory/poly.html">링크</a>에서 확인 가능하다.</p>
<h3 id="mathematical-concepts">Mathematical concepts</h3>
<p>$$Claim$$: $$n$$을 2보다 큰 소수라 하자. 그러면 아래 두 조건 중 하나를 반드시 만족한다.</p>
<p>$$a^d \equiv 1 \pmod n$$</p>
<p>$$a^{2^rd} \equiv -1 \pmod n \text{, for some }0 \le r \le s-1$$</p>
<p>$$Proof$$: <a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">페르마 소정리</a>에 따라 소수 $$n$$에 대해 $$a$$는 아래를 만족한다.</p>
<p>$$a^{n-1} \equiv 1 \pmod n$$</p>
<p>여기서 어떤 수 $$n$$가 홀수라면, $$n-1$$은 짝수다. 짝수는 2의 거듭제곱을 약수로 가지므로 다음과 같이 정의된다.</p>
<p>$$n-1 = 2^sd, , \text{d is odd}$$</p>
<p>따라서, $$a^{n-1} \equiv 1 \pmod n$$은 아래와 같이 변형할 수 있다.</p>
<p>$$\begin{align} a^{2^sd} &amp; = (a^{2^{s-1}d}-1)(a^{2^{s-1}d} + 1) \ &amp;= (a^{2^{s-2}d} - 1)(a^{2^{s-2}d} + 1)(a^{2^{s-1}d} + 1) \ &hellip; \ &amp;= (a^d - 1)(a^{2d} + 1)&hellip;(a^{2^{s-3}d} + 1)(a^{2^{s-2}d} + 1)(a^{2^{s-1}d} + 1) \end{align}$$</p>
<p>따라서, 두 조건 중 하나를 만족할 경우 $$n$$은 확률적으로 소수임을 알 수 있다.</p>
<h3 id="소수-판정-코드">소수 판정 코드</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>ull pow_with_mod(ull a, ull b, ull mod) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	a = a % mod;
</span></span><span style="display:flex;"><span>	ull ret = 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (b &gt; 0) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (b % 2 == 1) {
</span></span><span style="display:flex;"><span>			ret = (__int128_t)ret * a % mod;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		a = (__int128_t)a * a % mod;
</span></span><span style="display:flex;"><span>		b = b &gt;&gt; 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">bool</span> miller_rabin_primality_test(ull n, ull a) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ull d = n - 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (d % 2 == 0) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (pow_with_mod(a, d, n) == n - 1) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		d = d &gt;&gt; 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ull pow_of_a_d = pow_with_mod(a, d, n);
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> pow_of_a_d == n - 1 || pow_of_a_d == 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">bool</span> is_prime(ull n) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span>( n &lt;= 1 ) <span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (n &lt;= 1000000000ULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (ull i = 2; i * i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (n % i == 0) {
</span></span><span style="display:flex;"><span>				<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (ull a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (!miller_rabin_primality_test(n, a)) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h2 id="최종-코드">최종 코드</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> ull = <span style="color:#2b91af">unsigned</span> <span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector&lt;ull&gt; factors;
</span></span><span style="display:flex;"><span>ull n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">//NOTICE: __int128_t type only use in gcc
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#008000">//return a^b % mod with divide and conquer
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>ull pow_with_mod(ull a, ull b, ull mod) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	a = a % mod;
</span></span><span style="display:flex;"><span>	ull ret = 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (b &gt; 0) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (b % 2 == 1) {
</span></span><span style="display:flex;"><span>			ret = (__int128_t)ret * a % mod;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		a = (__int128_t)a * a % mod;
</span></span><span style="display:flex;"><span>		b = b &gt;&gt; 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">bool</span> miller_rabin_primality_test(ull n, ull a) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ull d = n - 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (d % 2 == 0) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (pow_with_mod(a, d, n) == n - 1) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		d = d &gt;&gt; 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ull pow_of_a_d = pow_with_mod(a, d, n);
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> pow_of_a_d == n - 1 || pow_of_a_d == 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">bool</span> is_prime(ull n) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span>( n &lt;= 1 ) <span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (n &lt;= 1000000000ULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (ull i = 2; i * i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (n % i == 0) {
</span></span><span style="display:flex;"><span>				<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (ull a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (!miller_rabin_primality_test(n, a)) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ull abs(ull a) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> a &gt; 0 ? a : -1 * a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">//Euclidean algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>ull gcd(ull a, ull b) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (a &lt; b) swap(a, b);
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (b == 0) <span style="color:#00f">return</span> a;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> gcd(b, a % b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">void</span> factorize(ull n) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (n &lt;= 1) <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (is_prime(n)) {
</span></span><span style="display:flex;"><span>		factors.push_back(n);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ull x = 2, q = 1, g = 1, xs, y, c = rand() % 10 + 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">auto</span> f = [=](ull x) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> ((__int128_t)x * x + c) % n;
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//Brent&#39;s Algorithm: Faster than Floyd&#39;s cycle-fiding algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#2b91af">int</span> m = 128;
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> l = 1;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (g == 1) {
</span></span><span style="display:flex;"><span>		y = x;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 1; i &lt; l; i++) {
</span></span><span style="display:flex;"><span>			x = f(x);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> k = 0;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">while</span> (k &lt; l &amp;&amp; g == 1) {
</span></span><span style="display:flex;"><span>			xs = x;
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; m &amp;&amp; i &lt; l - k; i++) {
</span></span><span style="display:flex;"><span>				x = f(x);
</span></span><span style="display:flex;"><span>				q = (__int128_t)q * abs(y - x) % n;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			g = gcd(q, n);
</span></span><span style="display:flex;"><span>			k += m;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		l *= 2;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (g == n) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>			xs = f(xs);
</span></span><span style="display:flex;"><span>			g = gcd(abs(xs - y), n);
</span></span><span style="display:flex;"><span>		} <span style="color:#00f">while</span> (g == 1);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	factorize(g);
</span></span><span style="display:flex;"><span>	factorize(n / g);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
</span></span><span style="display:flex;"><span>	cin &gt;&gt; n;
</span></span><span style="display:flex;"><span>	factorize(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sort(factors.begin(), factors.end());
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#00f">auto</span> factor : factors) {
</span></span><span style="display:flex;"><span>		cout &lt;&lt; factor &lt;&lt; <span style="color:#a31515">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><font size="6">Reference</font></p></blockquote>
<ul>
<li><a href="https://cp-algorithms.com/algebra/factorization.html#toc-tgt-9">https://cp-algorithms.com/algebra/factorization.html#toc-tgt-9</a></li>
<li><a href="https://ko.wikipedia.org/wiki/">https://ko.wikipedia.org/wiki/</a>폴라드_로_알고리즘</li>
<li><a href="https://aruz.tistory.com/140">https://aruz.tistory.com/140</a></li>
<li><a href="https://crypto.stanford.edu/pbc/notes/numbertheory/millerrabin.html">https://crypto.stanford.edu/pbc/notes/numbertheory/millerrabin.html</a></li>
<li><a href="https://casterian.net/archives/396">https://casterian.net/archives/396</a></li>
<li><a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test</a></li>
</ul>

</content>
<p>
  
  <a href="http://localhost:1313/blog/math/">#Math</a>
  
  <a href="http://localhost:1313/blog/number_theory/">#Number_theory</a>
  
  <a href="http://localhost:1313/blog/prime/">#Prime</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
