<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Database Internals | Hammer&#39;s Blog</title>
<meta name="title" content="Database Internals" />
<meta name="description" content="개요
해당 개시글은 데이터베이스 인터널스를 읽고 정리한 아티클입니다.
2장 B-트리 개요
디스크 기반 스토리지용 트리
이진 트리의 경우 트리의 fanout(한 노드가 가질 수 있는 최대 자식 노드의 개수)가 매우 낮기에 트리의 리밸런싱, 노드 재배치, 포인터 갱신이 자주 발생함.  잦은 포인터 갱신은 높은 유지 비용을 유발하고 디스크 기반 자료 구조로 부적합하다.
또한, 노드는 지역성 측면에서 새 노드는 부모 노드와 가까운 위치에 저장되지 않을 수 있음. (이를 paged binary tree 가 일부 해결해줄 수는 있음)" />
<meta name="keywords" content="database," />


<meta property="og:url" content="http://localhost:1313/database-internals/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="Database Internals">
  <meta property="og:description" content="개요 해당 개시글은 데이터베이스 인터널스를 읽고 정리한 아티클입니다.
2장 B-트리 개요 디스크 기반 스토리지용 트리 이진 트리의 경우 트리의 fanout(한 노드가 가질 수 있는 최대 자식 노드의 개수)가 매우 낮기에 트리의 리밸런싱, 노드 재배치, 포인터 갱신이 자주 발생함. 잦은 포인터 갱신은 높은 유지 비용을 유발하고 디스크 기반 자료 구조로 부적합하다.
또한, 노드는 지역성 측면에서 새 노드는 부모 노드와 가까운 위치에 저장되지 않을 수 있음. (이를 paged binary tree 가 일부 해결해줄 수는 있음)">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2020-11-12T00:23:48+09:00">
    <meta property="article:modified_time" content="2020-11-12T00:23:48+09:00">
    <meta property="article:tag" content="Database">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Database Internals">
  <meta name="twitter:description" content="개요 해당 개시글은 데이터베이스 인터널스를 읽고 정리한 아티클입니다.
2장 B-트리 개요 디스크 기반 스토리지용 트리 이진 트리의 경우 트리의 fanout(한 노드가 가질 수 있는 최대 자식 노드의 개수)가 매우 낮기에 트리의 리밸런싱, 노드 재배치, 포인터 갱신이 자주 발생함. 잦은 포인터 갱신은 높은 유지 비용을 유발하고 디스크 기반 자료 구조로 부적합하다.
또한, 노드는 지역성 측면에서 새 노드는 부모 노드와 가까운 위치에 저장되지 않을 수 있음. (이를 paged binary tree 가 일부 해결해줄 수는 있음)">




  <meta itemprop="name" content="Database Internals">
  <meta itemprop="description" content="개요 해당 개시글은 데이터베이스 인터널스를 읽고 정리한 아티클입니다.
2장 B-트리 개요 디스크 기반 스토리지용 트리 이진 트리의 경우 트리의 fanout(한 노드가 가질 수 있는 최대 자식 노드의 개수)가 매우 낮기에 트리의 리밸런싱, 노드 재배치, 포인터 갱신이 자주 발생함. 잦은 포인터 갱신은 높은 유지 비용을 유발하고 디스크 기반 자료 구조로 부적합하다.
또한, 노드는 지역성 측면에서 새 노드는 부모 노드와 가까운 위치에 저장되지 않을 수 있음. (이를 paged binary tree 가 일부 해결해줄 수는 있음)">
  <meta itemprop="datePublished" content="2020-11-12T00:23:48+09:00">
  <meta itemprop="dateModified" content="2020-11-12T00:23:48+09:00">
  <meta itemprop="wordCount" content="1093">
  <meta itemprop="keywords" content="Database">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>Database Internals</h1>
<p>
  <i>
    <time datetime='2020-11-12'>
      12 Nov, 2020
    </time>
  </i>
</p>

<content>
  <h1 id="개요">개요</h1>
<p>해당 개시글은 데이터베이스 인터널스를 읽고 정리한 아티클입니다.</p>
<h1 id="2장-b-트리-개요">2장 B-트리 개요</h1>
<h2 id="디스크-기반-스토리지용-트리">디스크 기반 스토리지용 트리</h2>
<p>이진 트리의 경우 트리의 fanout(한 노드가 가질 수 있는 최대 자식 노드의 개수)가 매우 낮기에 트리의 리밸런싱, 노드 재배치, 포인터 갱신이 자주 발생함.  잦은 포인터 갱신은 높은 유지 비용을 유발하고 디스크 기반 자료 구조로 부적합하다.</p>
<p>또한, 노드는 지역성 측면에서 새 노드는 부모 노드와 가까운 위치에 저장되지 않을 수 있음. (이를 paged binary tree 가 일부 해결해줄 수는 있음)</p>
<p>이진 트리는 fanout 이 상대적으로 낮기에 $O(logN)$ 번의 탐색과 디스크 전송이 필요,</p>
<h2 id="디스크-기반-자료-구조">디스크 기반 자료 구조</h2>
<p>결국 HDD, SSD 두 저장매체 모두 읽기를 개별 바이트 단위가 아니라, 메모리 청크 단위로 참조하기에 이는 디스크 기반 자료구조에서 염두해야할 가장 큰 제약사항임. B-tree 를 사용하는 이유 역시 고정 크기의 페이지를 단위로 구성하기 때문이다.</p>
<h2 id="hdd">HDD</h2>
<p>디스크에서는 탐색 작업이 대부분의 읽기 비용의 전부이다. 헤드를 원하는 물리적 위치까지 옮기는 가장 큰 비율을 차지하지만, 이후 연속적인 읽기/쓰기는 비교적 저렴함.
즉, 연속된 데이터에 대한 I/O 가 권장되야 함.</p>
<h2 id="ssd-스킵">SSD (스킵)</h2>
<h1 id="3장-파일-포맷">3장 파일 포맷</h1>
<p>디스크 기반 자료 구조와 인메모리 자료 구조의 포인터 관리는 같지않음. 페이지 단위로 구성되는 B-트리 자료구조이기에
디스크에 저장된 데이터는 read/write 로만 접근할 수있기에 이에 맞는 형식으로 데이터를 저장해야함.</p>
<p>가변길이의 포맷인 경우 보통 해당하는 사이즈와 실제 값을 같이 저장함</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>String{
</span></span><span style="display:flex;"><span>	size uint_16
</span></span><span style="display:flex;"><span>	data byte[size]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>데이터베이스 파일은 일반적으로 탐색에 유용한 Lookup 테이블, 오프셋과 시작점을 가리키는 헤더(or 트레일러)가 존재.
<img src="/assets/images/Pasted%20image%2020221010211308.png" alt="이미지"></p>
<h2 id="페이지-구조">페이지 구조</h2>
<h3 id="고정-길이-레코드의-페이지-구조">고정 길이 레코드의 페이지 구조</h3>
<p>처음 발표된 B-tree 논문에서는 고정 길이 데티어의 페이지 구조를 설명한다. 키, 포인터, 값들의 나열이다. 아래와 같은 구조는 단순하지만 단점이 존재함.</p>
<ul>
<li>빈 공간이 아닌 곳에 추가 시 여러 원소를 재배치해야하고, 가변길이 레코드를 효율적으로 관리 저장이 불가능하다.</li>
</ul>
<p><img src="/assets/images/Pasted%20image%2020221010211320.png" alt="이미지"></p>
<h3 id="slotted-page">Slotted Page</h3>
<p>페이지 포맷은 아래와 같은 조건을 충족해야한다.</p>
<ul>
<li>최소한의 오버헤드로 가변길이 레코드(variable-size records)를 저장해야함
<ul>
<li>페이지를 여러 개의 고정 길이 세그먼트로 분할하면 가변 길이 레코드를 저장할 수 있지만, 레코드 사이즈는 제 각기이기에 세그먼트 크기와 맞지 않는 레코드는 세그먼트의 일부를 사용하지 않는다.</li>
</ul>
</li>
<li>삭제된 레코드의 메모리 회수
<ul>
<li>이를 회수하고 기존에 레코드를 재배치하는 과정에서 다른 페이지가 재배치된 데이터를 참조할 수 있ㄱ디에, 레코드의 오프셋은 유지해야한다. 동시에 메모리 낭비 또한 고려해야 함.</li>
</ul>
</li>
<li>레코드의 정확한 위치와 상관없이 참조가능</li>
</ul>
<p>실제로 PSQL 이 Slotted Page 방식을 사용함. 슬롯 페이지는 레코드마다 고정길이의 헤더와 실제 레코드를 지닌다.</p>
<p><img src="/assets/images/Pasted%20image%2020221010212336.png" alt="이미지">
<a href="https://www.cubrid.com/blog/3822789">https://www.cubrid.com/blog/3822789</a></p>
<p>이를 통해 아래 문제를 해결할 수 있다.</p>
<ul>
<li>오버헤드 최소화: 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드.</li>
<li>공간 회수: 단편화 제거 및 페이지 재구성을 통해 공간을 회수 가능</li>
<li>동적 레이아웃: 슬롯은 ID 를 통해 페이지 외부에서 접근하기 때문에 정확한 위치는 페이지 내부에서만 필요함.</li>
</ul>
<h2 id="셀-병합을-통한한-슬롯-페이지-구성">셀 병합을 통한한 슬롯 페이지 구성</h2>
<p>레코드가 추가될 때마다, 셀을(실제 레코드에 저장되는 데이터 자세한 설명은 책에 나와있지만 생략함) 추가하고 오프셋을 특정 순서(ex: 사전순)에 맞게 정렬하여 이진 탐색이 가능하도록 함.</p>
<p><img src="/assets/images/Pasted%20image%2020221010213819.png" alt="이미지">
<img src="/assets/images/Pasted%20image%2020221010213826.png" alt="이미지"></p>
<h3 id="가변길이-데이터를-관리하는-방법">가변길이 데이터를 관리하는 방법</h3>
<p>페이지 레코드 삭제 시 해제된 공간으로 다른 셀을 옮길 필요는 없고, 메모리에 저장된 Availability List 에 위치를 가리키는 포인터만 업데이트 하는 방식으로도 사용 가능하다.</p>
<p>단편화된 페이지에서 적합한 세그먼트가 있는지를 확인하고, <strong>페이지에 남아있는 바이트 수를 계산해두어 저장할 수 있을지에 대한 빠른 확인이 가능하도록 한다.</strong></p>
<p>First Fit, Best Fit 정책에 따라 선택하며 단편화된 집합의 바이트 크기가 충분할 경우에는 모든 셀을 읽고 재배치하는 과정이 포함됨.</p>
<p><img src="/assets/images/Pasted%20image%2020221010213911.png" alt="이미지"></p>
<h1 id="4장-b-트리-구현">4장 B-트리 구현</h1>
<p>책에서는 페이지 == 트리의 노드임을 상기하자.</p>
<h2 id="페이지-기반-노드의-구조의-대한-상세한-설명">페이지 기반 노드의 구조의 대한 상세한 설명</h2>
<h3 id="페이지-헤더">페이지 헤더</h3>
<p>탐색과 유지보수, 최적화에 필요한 정보를 저장함. 플래그 레이아웃, 셀 개수, 빈 공간을 가리키는 오프셋.</p>
<h3 id="매직-넘버">매직 넘버</h3>
<p>페이지 종류와 버전과 같은 정보를 포함하는 멀티바이트 블록,</p>
<h3 id="형제-링크">형제 링크</h3>
<p>좌우 형제 페이지를 가리키는 링크로써, 상위 노드로 넘어가지 않고 쉽게 이웃 노드를 참조할 수 있도록 도움. 다만, 삭제 및 업데이트 시 분할과 병합이 일어난다면 해당 링크도 갱신해야하기에 더 복잡해짐.</p>
<h3 id="rightmost-pointers가장-오른쪽-포인터">Rightmost Pointers(가장 오른쪽 포인터)</h3>
<p>B-tree 구조를 설명했다 싶이, 반드시 포인터가 키보다 하나 더 있음. 이를 SQLite 는 헤더 정보에 저장함.
<img src="/assets/images/Pasted%20image%2020221017232819.png" alt="이미지"></p>
<h3 id="node-high-keys">Node High Keys</h3>
<p>가장 오른쪽 포인터 처리가 쉬워짐. 모든 키 짝이 맞게됨.
<img src="/assets/images/Pasted%20image%2020221017232921.png" alt="이미지"></p>
<h3 id="overflow-pages">Overflow Pages</h3>
<p>기본 페이지 크기(ex 4K) 를 넘었다면 새로 할당된 오버플로우 페이지에 원본 페이지를 연결하고 이를 저장한다.</p>
<h2 id="이진-검색">이진 검색</h2>
<h3 id="indirection-pointers-를-이용한-이진-검색">Indirection Pointers 를 이용한 이진 검색</h3>
<p>페이지 저장방식은 입력 순서대로 레코드를 저장하며 실제로는 Indirection Pointers 를 이용해 아이템을 확인함.</p>
<h2 id="분할과-병합">분할과 병합</h2>
<p>형제 포인터 및 부모 포인터는 반드시 분할과 병합 시 갱신해주어야 함. <a href="https://github.com/wiredtiger/wiredtiger/blob/f08bc4b18612ef95a39b12166abcccf207f91596/src/include/btmem.h#L550">WiredTiger</a> 같은 경우에는 형제 포인터로 발생할 수 있는 데드락을 제거하기 위해 부모 포인터를 사용하기도 함.</p>
<h3 id="탐색-경로breadcrumbs">탐색 경로(Breadcrumbs)</h3>
<p>삽입 삭제 시 타고온 경로를 다시 순회하는 방식이기에. 탐색 경로를 저장해 사용할 수도 있음. PSQL 은 <a href="https://github.com/postgres/postgres/blob/REL_12_STABLE/src/include/access/nbtree.h#L405-L423">BTStack</a> 을 사용함</p>
<p><img src="/assets/images/Pasted%20image%2020221017234008.png" alt="이미지"></p>
<h2 id="리밸런싱">리밸런싱</h2>
<p>분할 및 병합 비용은 비싸기에, 특정 레벨의 원소를 리밸런싱하거나 이를 방지하기 위해 빈공간이 많은 노드로 데이터를 최대한 옮김. 비용이 발생하긴 하나, 레벨을 낮추고 노드 점유율을 증진시킬 수 있음.</p>
<p>물론, 삽입 삭제 시 <strong>로드 밸런싱</strong> 수행하는 방법도 있음. 효율적인 공간 활용을 위해 노드를 분할하는 대신 형제 노드로 일부 원소를 옮기고 삽입할 공간을 확보함.</p>
<p>B*-Trees 는 형제 노드에 찰 때까지 이웃 노드 간에 원소를 분산하는데, 하나를 기준으로 하는 게 아니라 2개를 기준으로 전체가 2/3 으로 찰 때가지 분산함. 부하를 지연시키고, 점유율을 높일 수 있지만 균형을 맞추는 로직이 추가로 더 필요함. 다만, 순회 시 효율성 또한 높아짐. SQLite 이 이와 비슷한로드 밸런싱을 (<a href="https://www.sqlite.org/btreemodule.html#balance_siblings">balance sibling algorithm</a>) 수행함.</p>
<h2 id="right-only-appends">Right-Only Appends</h2>
<p>단조 증가 auto-incremented 인 키를 대부분이 프라이머리 키로 사용하기에, 대부분 각 레벨의 가장 오른쪽 노드에서 분할 작업이 일어난다. 이는 최적화 대상이.
PSQL 에서는 이러한 최적화 방식을 <a href="https://github.com/postgres/postgres/blob/bf491a9073e12ce1fc3e6facd0ae1308534df570/src/backend/access/nbtree/nbtinsert.c#L127-L144">Fastpath</a>라고 하는데, 전문은 아래와 같다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008000">/*
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* It&#39;s very common to have an index on an auto-incremented or
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* monotonically increasing value. In such cases, every insertion happens
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* towards the end of the index. We try to optimize that case by caching
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* the right-most leaf of the index. If our cached block is still the
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* rightmost leaf, has enough free space to accommodate a new entry and
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* the insertion key is strictly greater than the first key in this page,
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* then we can safely conclude that the new key will be inserted in the
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* cached block. So we simply search within the **cached block and insert
</span></span></span><span style="display:flex;"><span><span style="color:#008000">* the key at the appropriate location.** We call it a fastpath.
</span></span></span><span style="display:flex;"><span><span style="color:#008000">*
</span></span></span></code></pre></div><p><strong>항상 새로운 키값은 가장 오른쪽 페이지의 첫번째 키보다 큼이 보장되기에 공간이 충분하다면 바로 캐시된 페이지에 새 키값을 삽입한다.</strong></p>
<h3 id="벌크로딩">벌크로딩</h3>
<p>잘 모르겠음.</p>
<h2 id="압축">압축</h2>
<p>실제 raw 데이터 저장 시 상당한 오버헤드가 있을 수 있지만, 압축은 RAM, CPU 사이클을 소모하기에 조심해야함. 데이터 셋이 클 수록 작은 압축단위가 적절함.</p>
<p>Disk 는 블록 단위로 불러오기에 아래와 같은 상황이 발생할 수 있다.
압축된 값 (a) 만이 필요한데, (b)까지 불러와질 수 있음.</p>
<p><img src="/assets/images/Pasted%20image%2020221018000553.png" alt="이미지"></p>
<h2 id="vacuum-and-maintenance">Vacuum and Maintenance</h2>
<p>앞에서 설명한 slotted page 는 설계상 추가 처리가 필요하다. 삭제 업데이트 삽입 등 작업이 일어나면 계속해서 단편화가 발생해 논리적 공간은 충분하지만, 연속적인 물리적 공간이 부족할 수 있음.
<img src="/assets/images/Pasted%20image%2020221018001121.png" alt="이미지">
비어 있는 값은 가비지 영역이다.</p>
<h3 id="단편화">단편화</h3>
<p>페이지를 compaction 를 위해 vacuum process 를 가비지 컬렉터가 진행하거나 오프셋을 덮어 씌울 수 있음.</p>
<blockquote>
<p>MVCC 구현을 위해 바로 삭제된 셀을 덮어 씌우거나 삭제하지 않고 둔다. 트랜잭션 동안 이를 접근할 수 있으며, 롤백이나 고스트 레코드에 접근하는 트랜잭션이 끝날 때까지 기다렸다가 가비지 컬렉터가 이를 회수한다.</p></blockquote>
<p>보통 연속화된 데이터를 필요로 하기에 죽은 셀들은 비동기 적으로 컴팩션이 필요한 경우가 잦음.</p>
<h1 id="5장-트랜잭션-처리와-복구">5장 트랜잭션 처리와 복구</h1>

</content>
<p>
  
  <a href="http://localhost:1313/blog/database/">#Database</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
