<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Traversal on Hammer&#39;s Blog</title>
    <link>http://localhost:1313/blog/traversal/</link>
    <description>Recent content in Traversal on Hammer&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© 조원빈 - All rights reserved</copyright>
    <atom:link href="http://localhost:1313/blog/traversal/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Heavy-Light Decompostion(작성중)</title>
      <link>http://localhost:1313/heavy-light-decompostion%EC%9E%91%EC%84%B1%EC%A4%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/heavy-light-decompostion%EC%9E%91%EC%84%B1%EC%A4%91/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;오늘은 &lt;code&gt;HLD&lt;/code&gt;에 대해 포스팅을 해보려 한다. 문제 유형이 한정적이고 어려운 테크닉에 속하기에 포스팅할까 망설였다.(어디다 쓰는 알고리즘인데 도대체) 대회 준비를 하는 것도 아니기에 기본적인 자료구조, 알고리즘을 지향하려 했지만, 최근에는 굳이 그럴 필요 있을까 생각한다.&lt;/p&gt;&#xA;&lt;p&gt;알고리즘은 기업 코테도 있다보니 겸사겸사 시작했지만, 요즘은 하나의 논리를 배우는 거라 생각한다. 우리는 개발을 하면서 언어에 대해 항상 문법만 배우지 말을 잘하는 법을 배우진 않는다. 논리적으로 말하지 않아도 의미만 잘 전달된다면 상관없을지도 모른다. 하지만, 직업 특성상 우리는 항상 효율적인 것을 생각한다. 논리를 배우는 건 필수적이지 않지만 달변가들이 많은 논리를 알고 있는 것은 어찌보면 당연하지 않을까?&lt;/p&gt;</description>
    </item>
    <item>
      <title>parallel binary search</title>
      <link>http://localhost:1313/parallel-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/parallel-binary-search/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;parallel-binary-search&#34;&gt;parallel binary search&lt;/h1&gt;&#xA;&lt;p&gt;어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, &amp;hellip; q_n}$$이 있다 하자.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/pbs.png&#34; alt=&#34;이미지&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;음악-추천&#34;&gt;음악 추천&lt;/h2&gt;&#xA;&lt;h3 id=&#34;입력&#34;&gt;입력&lt;/h3&gt;&#xA;&lt;p&gt;입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
