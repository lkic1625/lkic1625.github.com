<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Hammer&#39;s Blog</title>
    <link>http://localhost:1313/categories/algorithm/</link>
    <description>Recent content in Algorithm on Hammer&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <copyright>© 조원빈 - All rights reserved</copyright>
    <atom:link href="http://localhost:1313/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>bipartite matching</title>
      <link>http://localhost:1313/bipartite-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bipartite-matching/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;bipartite-matching이분-매칭&#34;&gt;Bipartite Matching(이분 매칭)&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1-graph-mathcing&#34;&gt;1. Graph Mathcing&lt;/h2&gt;&#xA;&lt;p&gt;Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다.&#xA;아래 사진은 올바른 매칭이 진행되었을 때 결과이다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/matching.png&#34; alt=&#34;그래프 이미지&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다.&#xA;하지만 가장 General한 Mathcing 알고리즘은 &lt;a href=&#34;https://en.wikipedia.org/wiki/Blossom_algorithm&#34;&gt;꽤나 복잡하여&lt;/a&gt; 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-이분매칭&#34;&gt;2. 이분매칭&lt;/h2&gt;&#xA;&lt;p&gt;이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다.&#xA;이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>closest pair</title>
      <link>http://localhost:1313/closest-pair/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/closest-pair/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;definition&#34;&gt;definition&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;input: $$p_1, p_2, p_3, &amp;hellip; p_n$$  $$(p_i = (x_i, y_i))$$&lt;/li&gt;&#xA;&lt;li&gt;output: $$p_i, p_j$$ with smallest $$p_i - p_j$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;brute-force-algorithm&#34;&gt;Brute-force algorithm&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;minDist = infinity&#xA;for i = 1 to length(P) - 1 do&#xA;    for j = i + 1 to length(P) do&#xA;        let p = P[i], q = P[j]&#xA;        if dist(p, q) &amp;lt; minDist  then&#xA;            minDist = dist(p, q)&#xA;            closestPair = (p, q)&#xA;return closestPair&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time complexity: $$O(n^2)$$&lt;/p&gt;&#xA;&lt;h1 id=&#34;divide-and-conquer-algorithm&#34;&gt;Divide and Conquer algorithm&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;점들을 x좌표에 따라 정렬한다.&lt;/li&gt;&#xA;&lt;li&gt;점들이 두개의 같은 크기의 집합으로 나뉘도록 수직선 $$x = x_mid$$를 기준으로 양옆으로 분할한다.&lt;/li&gt;&#xA;&lt;li&gt;왼쪽과 오른쪽의 점들의 집합에 대해 재귀적으로 문제를 해결한다. 이것을 통해 왼쪽과 오른쪽에서의 최근접 거리인 $$d_{Lmin}$$과 $$d_{Rmin}$$을 찾을 수 있다.&lt;/li&gt;&#xA;&lt;li&gt;분할선 기준으로 나뉜 쌍들이 존재할 수 있으므로 중간에 존재하는 쌍들 중 거리가 최소가 되는 $$d_{LRmin}$$을 구한다.&lt;/li&gt;&#xA;&lt;li&gt;최종적으로 찾고자 하는 최근접 거리는 $$d = min(d_{Lmin}, d_{Rmin}, d_{LRmin})$$이다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;time-complexity&#34;&gt;time complexity&lt;/h2&gt;&#xA;&lt;p&gt;시간복잡도의 가장 영향을 미치는 부분인 4번 항목에 대해 알아보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>covex hull</title>
      <link>http://localhost:1313/covex-hull/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/covex-hull/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;graham-scan&#34;&gt;Graham Scan&lt;/h1&gt;&#xA;&lt;h2 id=&#34;pseudo-code&#34;&gt;pseudo code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sort by y-order; //$$p_1, p_2, ..., p_n$$&#xA;stack.push($$p_1, p_2$$);&#xA;for i = 3 to $$n$$ do&#xA;  while next $$\angle next, top, $$p_i$$ != CCW&#xA;    stack.pop()&#xA;  stack.push($$p_i$$)&#xA;return stack&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;analysis-of-graham-scan&#34;&gt;Analysis of Graham Scan&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Invariant $$&amp;lt;p_1, &amp;hellip; ,stack.top()&amp;gt;$$ is convex&lt;/li&gt;&#xA;&lt;li&gt;기울기 공식:&#xA;$$D = det\begin{vmatrix} 1 &amp;amp; p_x &amp;amp; p_y \ 1 &amp;amp; q_x &amp;amp; q_y \ 1 &amp;amp; r_x &amp;amp; r_y \end{vmatrix}$$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;if $$D &amp;gt; 0$$ then $$\angle p, q, r$$ is CCW&lt;/li&gt;&#xA;&lt;li&gt;else if $$D &amp;lt; 0$$ $$\angle p, q, r$$ is CW&lt;/li&gt;&#xA;&lt;li&gt;else then $$\angle p, q, r$$ is straight&lt;/li&gt;&#xA;&lt;li&gt;$$D = p \cdot (q \times r)$$ 이다.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;정렬 이후 $$O(n)$$번의 스캔이 일어나며 반복 수행마다 $$logn$$의 시간 소요&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;time complexity: $$O(nlogn)$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and Conquer&lt;/h1&gt;&#xA;&lt;h2 id=&#34;pseudo-code-1&#34;&gt;pseudo code&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/merging.PNG&#34; alt=&#34;이미지1&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>dynamic programming</title>
      <link>http://localhost:1313/dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dynamic-programming/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;chained-matrix-multiplication&#34;&gt;chained matrix multiplication&lt;/h1&gt;&#xA;&lt;p&gt;$$input$$: $$d_0, d_1 &amp;hellip; d_n$$ $$(\text{size of }M_i = d_{i-1} \times d_i)$$&lt;br&gt;&#xA;$$output$$: $$D(i, j) = M_i \times M_{i+1} \times &amp;hellip; \times M_j$$ 의 최소비용&lt;/p&gt;&#xA;&lt;h2 id=&#34;점화식&#34;&gt;점화식&lt;/h2&gt;&#xA;&lt;p&gt;$$\text{for all i}\in S,  D(i,i) = 0$$&#xA;$$D(i, j) = min_{i \le k \le j}(D(i, k) + D(k + 1,j) + d_{i-1} \times d_k \times d_j$$&lt;/p&gt;&#xA;&lt;h2 id=&#34;알고리즘&#34;&gt;알고리즘&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/matchainmul.PNG&#34; alt=&#34;행렬이미지&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;edit-distance&#34;&gt;edit distance&lt;/h1&gt;&#xA;&lt;p&gt;편집거리 알고리즘은 두 문자열의 유사도를 판단하는 알고리즘이다.&lt;/p&gt;&#xA;&lt;p&gt;유사도를 판단하는 기준은 삽입, 삭제, 변경을 몇 번 진행해야 바꿀 수 있는지 최소값을 구하여 판단한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>edit distance(moved)</title>
      <link>http://localhost:1313/edit-distancemoved/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/edit-distancemoved/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;edit-distance&#34;&gt;edit distance&lt;/h1&gt;&#xA;&lt;p&gt;이 포스트는 &lt;a href=&#34;http://localhost:1313/algorithm/dynamic_programming/#edit-distance&#34;&gt;여기로&lt;/a&gt; 옮겨졌습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>floyd warshall(moved)</title>
      <link>http://localhost:1313/floyd-warshallmoved/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/floyd-warshallmoved/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;floyd-warshall&#34;&gt;floyd warshall&lt;/h1&gt;&#xA;&lt;p&gt;이 포스트는 &lt;a href=&#34;http://localhost:1313/algorithm/dynamic_programming/#floyd-warshall&#34;&gt;여기로&lt;/a&gt; 옮겨졌습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ford-fulkerson</title>
      <link>http://localhost:1313/ford-fulkerson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/ford-fulkerson/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;network-flow&#34;&gt;network flow&lt;/h1&gt;&#xA;&lt;h2 id=&#34;flow-network란&#34;&gt;flow network란&lt;/h2&gt;&#xA;&lt;p&gt;그래프 이론에서 &lt;code&gt;flow network&lt;/code&gt;란 각각의 &lt;code&gt;edge&lt;/code&gt;가 &lt;code&gt;capacity&lt;/code&gt;을 가지고 있고 &lt;code&gt;flow&lt;/code&gt;를 전달하는 &lt;code&gt;Directed Graph&lt;/code&gt;이다.&lt;/p&gt;&#xA;&lt;p&gt;네트워크는 &lt;code&gt;graph&lt;/code&gt;이며 $$G = (V, E)$$, $$V$$는 정점의 집합, $$E$$는 $$V$$의 간선의 집합으로써 $$V$$ x $$V$$의 &lt;code&gt;subset&lt;/code&gt;이다.&#xA;이와 함께 $$c: V$$ x $$V → ℝ∞$$ 용량 함수 또한 정의된다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Without_loss_of_generality&#34;&gt;$$WLOG$$&lt;/a&gt;&lt;br&gt;&#xA;if $$(u, v) ∈ E$$ then $$(v, u) ∈ E$$&lt;br&gt;&#xA;if $$(u, v) ∉ E$$ then $$c(v, u)$$ = 0&lt;/p&gt;&#xA;&lt;p&gt;서로 다른 노드 &lt;code&gt;source&lt;/code&gt; $$s$$와 &lt;code&gt;sink&lt;/code&gt; $$t$$가 구분될 경우 $$(G, c, s, t)$$ 를 &lt;code&gt;flow network&lt;/code&gt;라 한다.&#xA;&lt;img src=&#34;%5Cassets%5Cimages%5CNetwork_Flow.svg.png&#34; alt=&#34;이미지1&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ford-fulkerson 정당성 증명</title>
      <link>http://localhost:1313/ford-fulkerson-%EC%A0%95%EB%8B%B9%EC%84%B1-%EC%A6%9D%EB%AA%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/ford-fulkerson-%EC%A0%95%EB%8B%B9%EC%84%B1-%EC%A6%9D%EB%AA%85/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;p&gt;이 포스트는 &lt;a href=&#34;../ford_fulkerson&#34;&gt;FordFulkerson&lt;/a&gt;의 정당성 증명에 관한 포스트입니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;proof-of-correctness&#34;&gt;proof of correctness&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cut-이란&#34;&gt;cut 이란.&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Min-cut&lt;/code&gt; 문제를 이용하여 증명을 하기 때문에 먼저 &lt;code&gt;cut&lt;/code&gt;에 대해 알아보자&lt;/p&gt;&#xA;&lt;p&gt;그래프 이론에서 &lt;code&gt;cut&lt;/code&gt;이란 그래프의 정점을 두 개의 서로소 부분집합으로 분할 하는 것을 말한다. 어떤 컷이든 하나의 끝점이 있는 간선의 집합 &lt;code&gt;cut-set&lt;/code&gt;을 결정한다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;flow netwrok&lt;/code&gt;에서는  &lt;code&gt;s-t cut&lt;/code&gt;이라하며, 소스와 싱크를 다른 부분집합에 속하게 한다. 이 때 &lt;code&gt;cut-set&lt;/code&gt;은 반드시 소스에서 싱크로가는 간선만을 포함한다. &lt;code&gt;The capacity of an s–t cut&lt;/code&gt;은  &lt;code&gt;cut-set&lt;/code&gt;의 포함되는 간선의 용량의 총합이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Heavy-Light Decompostion(작성중)</title>
      <link>http://localhost:1313/heavy-light-decompostion%EC%9E%91%EC%84%B1%EC%A4%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/heavy-light-decompostion%EC%9E%91%EC%84%B1%EC%A4%91/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;오늘은 &lt;code&gt;HLD&lt;/code&gt;에 대해 포스팅을 해보려 한다. 문제 유형이 한정적이고 어려운 테크닉에 속하기에 포스팅할까 망설였다.(어디다 쓰는 알고리즘인데 도대체) 대회 준비를 하는 것도 아니기에 기본적인 자료구조, 알고리즘을 지향하려 했지만, 최근에는 굳이 그럴 필요 있을까 생각한다.&lt;/p&gt;&#xA;&lt;p&gt;알고리즘은 기업 코테도 있다보니 겸사겸사 시작했지만, 요즘은 하나의 논리를 배우는 거라 생각한다. 우리는 개발을 하면서 언어에 대해 항상 문법만 배우지 말을 잘하는 법을 배우진 않는다. 논리적으로 말하지 않아도 의미만 잘 전달된다면 상관없을지도 모른다. 하지만, 직업 특성상 우리는 항상 효율적인 것을 생각한다. 논리를 배우는 건 필수적이지 않지만 달변가들이 많은 논리를 알고 있는 것은 어찌보면 당연하지 않을까?&lt;/p&gt;</description>
    </item>
    <item>
      <title>monotone stack</title>
      <link>http://localhost:1313/monotone-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/monotone-stack/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;inroduction&#34;&gt;Inroduction&lt;/h1&gt;&#xA;&lt;p&gt;오늘 다뤄볼 알고리즘은 &lt;code&gt;monotone stack&lt;/code&gt;이다 특정 PS 기법으로 사용되기에 예제와 함께 풀어보겠다.&lt;/p&gt;&#xA;&lt;p&gt;내가 지금 듣고 있는 노래는 &lt;code&gt;민수 - 생일노래&lt;/code&gt;다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;monoton-stack&#34;&gt;Monoton Stack&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Monotone Stack&lt;/code&gt;은 이름처럼 단조 증가(감소) 스택을 만든다.&lt;/p&gt;&#xA;&lt;p&gt;다만, 증가하는 스택의 규칙을 따르도록 구성하려면 &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;가 필수적이다.&#xA;위 과정에서 저장해두었던 여러 정보를 통해 PS를 푸는 기법이다.&lt;/p&gt;&#xA;&lt;p&gt;위 설명만 하자니 솔직히 나라도 못 알아 들을 것 같다. 애초에 기법 또한 특정 알고리즘이라기 보단 &lt;code&gt;sliding window&lt;/code&gt;와 같은 방법론적인 부분이 크다 생각하여 예시가 꼭 필요해보인다. 보통은 알고리즘의 설명 이후 문제를 소개하곤 하지만, 이번엔 문제를 먼저 소개해보도록 하자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>parallel binary search</title>
      <link>http://localhost:1313/parallel-binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/parallel-binary-search/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;parallel-binary-search&#34;&gt;parallel binary search&lt;/h1&gt;&#xA;&lt;p&gt;어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.&lt;/p&gt;&#xA;&lt;p&gt;단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, &amp;hellip; q_n}$$이 있다 하자.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/pbs.png&#34; alt=&#34;이미지&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;음악-추천&#34;&gt;음악 추천&lt;/h2&gt;&#xA;&lt;h3 id=&#34;입력&#34;&gt;입력&lt;/h3&gt;&#xA;&lt;p&gt;입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pollard&#39;s rho algorithm</title>
      <link>http://localhost:1313/pollards-rho-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/pollards-rho-algorithm/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;이번 포스트에서 다룰 알고리즘은 폴라드 $$\rho$$ 알고리즘이다. 폴라드 $$\rho$$ 알고리즘은 빠른 소인수 분해를 위한 알고리즘이다.&lt;/p&gt;&#xA;&lt;p&gt;백준에 &lt;a href=&#34;https://www.acmicpc.net/problem/4149&#34;&gt;큰 수 소인수분해 4149&lt;/a&gt; 문제 풀이와 함께 진행하겠다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;core-ideas&#34;&gt;Core ideas&lt;/h1&gt;&#xA;&lt;p&gt;소인수 분해하려는 숫자 $$n = pq$$에서 $$p$$는 자명하지 않은 &lt;b&gt;인수&lt;/b&gt;라고 가정하자. 다항식을 $$n$$으로 나누는 연산 $$g(x) = (x^2 + 1)\text{ mod n}$$은 암호학에 유사난수 수열을 생성(&lt;code&gt;PRG&lt;/code&gt;)할 때 사용된다.&lt;/p&gt;&#xA;&lt;p&gt;이때 시작값을 적당히 2로 설정하면&lt;/p&gt;&#xA;&lt;p&gt;$$x_1 = g(2),,x_2=g(g(2)),,x_3=g(g(g(2)))$$&lt;/p&gt;&#xA;&lt;p&gt;위와 같은 형태로 수열이 생성된다. 이를 $${x_k}$$라 하자. 그러면 이 수열은 다른 수열 $${x_k ,mod,p}$$ 과 관련이 있다. 하지만 $$p$$가 사전에 주어지지 않았기 때문에, 두 번째 수열은 위 알고리즘으로 계산 불가능하다. 여기서 첫 번째 수열과 두 번째 수열의 관계가 &lt;code&gt;폴라드 로&lt;/code&gt; 알고리즘의 &lt;b&gt;핵심&lt;/b&gt; 아이디어다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>scheduling</title>
      <link>http://localhost:1313/scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/scheduling/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;activity-selection-problem&#34;&gt;activity selection problem&lt;/h1&gt;&#xA;&lt;p&gt;$$n$$개의 팀이 회의하고 싶은 시간을 제출했다고 했을 때 한 개의 회의실에서 선택할 수 있는 최대 회의 개수는?&lt;/p&gt;&#xA;&lt;p&gt;$$input$$: $$j_1, j_2, j_3, &amp;hellip; j_n$$ ($$j_i = (s_i, f_i)$$)&lt;br&gt;&#xA;$$output$$: maximum number of scheduled interval.&lt;/p&gt;&#xA;&lt;h2 id=&#34;알고리즘&#34;&gt;알고리즘&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;목록 $$S$$에 남는 회의 중 가장 일찍 끝나는 회의 $$S_{min}$$을 선택한다.&lt;/li&gt;&#xA;&lt;li&gt;$$S_{min}$$과 겹치는 회의를 $$S$$에서 모두 지운다.&lt;/li&gt;&#xA;&lt;li&gt;$$S$$가 텅빌 때까지 반복한다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;정확성-증명&#34;&gt;정확성 증명&lt;/h2&gt;&#xA;&lt;p&gt;$$Claim$$: 가장 종료 시간이 빠른 회의($$S_{min}$$)를 포함하는 최적해가 반드시 존재한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>segment tree</title>
      <link>http://localhost:1313/segment-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/segment-tree/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;구간별로 합을 저장해두는 자료구조이다. 특정 쿼리에 대해 $$O(logn + k)$$로 처리 가능하며 공간 복잡도와 생성 과정에서 $$O(nlogn)$$이 사용된다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;구조-설명&#34;&gt;구조 설명&lt;/h2&gt;&#xA;&lt;p&gt;$$S$$를 구간 혹은 세그먼트의 집합이라고 하고, $$p_1, p_2, &amp;hellip;, p_m$$을 오름차순으로 정렬한 구간의 끝점 (혹은 &lt;code&gt;endpoint&lt;/code&gt;)라 하자.&#xA;각각의 점에 따라 분할되는 구간을 생각했을 때 이를 &lt;code&gt;elementary intervals&lt;/code&gt;라 한다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/assets/images/seg_tree_intervals.png&#34; alt=&#34;이미지1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;elementary intervals&lt;/code&gt;들은 연속적인 두 개의 끝점에선 개구간을, 한 점으로 이루어진 경우에는 폐구간을 갖는다.&#xA;한 점을 구간으로 취급하는 이유는 쿼리에 대한 응답에서 내부의 끝점과 &lt;code&gt;elementary intervals&lt;/code&gt;를 구분할 필요가 없기 때문이다(?)&lt;/p&gt;</description>
    </item>
    <item>
      <title>shortest path</title>
      <link>http://localhost:1313/shortest-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/shortest-path/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;definition&#34;&gt;definition&lt;/h1&gt;&#xA;&lt;p&gt;$$input$$: $$G=(V,E,g), v_0 \in V$$&lt;br&gt;&#xA;$$output$$: shortest path $$v_0$$ to $$v_i$$ $$(v_i \in V)$$&lt;/p&gt;&#xA;&lt;h1 id=&#34;다익스트라-알고리즘&#34;&gt;다익스트라 알고리즘&lt;/h1&gt;&#xA;&lt;p&gt;다익스트라 알고리즘은 &lt;code&gt;Invariant&lt;/code&gt;를 중심으로 진행된다. 이는 아래와 같다&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;: $$\forall{u} \in T, d_{min}(u) = \text{shortest path}$$&lt;/li&gt;&#xA;&lt;li&gt;$$\forall{u} \notin T, \text{shortest path} v_0 \to T_0 \to u is \text{shortest path then insert u to T} (T_0 \in T)$$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;정확성-증명&#34;&gt;정확성 증명&lt;/h2&gt;&#xA;&lt;p&gt;Proof of Dijkstra&amp;rsquo;s algorithm is constructed by induction on the number of visited nodes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>topological sort</title>
      <link>http://localhost:1313/topological-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/topological-sort/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;definition&#34;&gt;Definition&lt;/h1&gt;&#xA;&lt;p&gt;$$input$$: $$DAG(\text{Directed Acyclic Graph})$$&lt;br&gt;&#xA;$$output$$: Node sequence $$(v_1, v_2, &amp;hellip; , v_n)$$ such that no edge $$v_j \to v_i$$ (j &amp;gt; i)&lt;/p&gt;&#xA;&lt;h1 id=&#34;invariant&#34;&gt;Invariant&lt;/h1&gt;&#xA;&lt;p&gt;$$DAG$$에서 $$indegree$$가 0인 노드는 반드시 존재한다.&lt;/p&gt;&#xA;&lt;p&gt;$$Proof$$:&#xA;$$indegree$$가 0인 노드가 하나도 없는 $$DAG$$를 가정하자. 모든 노드는 그러면 $$indegree$$가 1보다 크거나 같다.&lt;/p&gt;&#xA;&lt;p&gt;어떤 노드 하나를 골라 $$indegree$$가 가리키는 부모 노드를 탐색할 때,&#xA;모든 노드들은 $$indegree$$가 0이상이기 때문에 반드시 부모 노드를 가지게 된다.&lt;/p&gt;&#xA;&lt;p&gt;노드의 개수는 무한하지 않기 때문에 이 탐색은 순환하며 가정이 모순임을 나타낸다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>tree diameter</title>
      <link>http://localhost:1313/tree-diameter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/tree-diameter/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;&#xA;src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&#34;&gt;&#xA;&lt;/script&gt;&#xA;&lt;h1 id=&#34;트리의-지름&#34;&gt;트리의 지름&lt;/h1&gt;&#xA;&lt;h2 id=&#34;문제&#34;&gt;문제&lt;/h2&gt;&#xA;&lt;p&gt;트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.&lt;/p&gt;&#xA;&lt;p&gt;이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
