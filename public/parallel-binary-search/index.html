<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>parallel binary search | Hammer&#39;s Blog</title>
<meta name="title" content="parallel binary search" />
<meta name="description" content="
parallel binary search
어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.
단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, &hellip; q_n}$$이 있다 하자.

위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.
음악 추천
입력
입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다." />
<meta name="keywords" content="algorithm,traversal," />


<meta property="og:url" content="http://localhost:1313/parallel-binary-search/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="parallel binary search">
  <meta property="og:description" content="parallel binary search 어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.
단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, … q_n}$$이 있다 하자.
위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.
음악 추천 입력 입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:tag" content="Algorithm">
    <meta property="article:tag" content="Traversal">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="parallel binary search">
  <meta name="twitter:description" content="parallel binary search 어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.
단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, … q_n}$$이 있다 하자.
위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.
음악 추천 입력 입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.">




  <meta itemprop="name" content="parallel binary search">
  <meta itemprop="description" content="parallel binary search 어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.
단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, … q_n}$$이 있다 하자.
위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.
음악 추천 입력 입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.">
  <meta itemprop="wordCount" content="800">
  <meta itemprop="keywords" content="Algorithm,Traversal">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>parallel binary search</h1>
<p>
  <i>
    <time datetime='0001-01-01'>
      01 Jan, 0001
    </time>
  </i>
</p>

<content>
  <script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<h1 id="parallel-binary-search">parallel binary search</h1>
<p>어떤 문제가 요구하는 정답이 단조 증가 모양을 가질 때 이를 이용하여 답을 빠르게 구할 수 있다.</p>
<p>단조 증가하며, 순서대로 진행하는 쿼리 $$Q = {q_1, q_2, &hellip; q_n}$$이 있다 하자.</p>
<p><img src="/assets/images/pbs.png" alt="이미지"></p>
<p>위 그림과 같이 쿼리에 대하여 binary search를 진행할 수 있는 경우, 문제공간에 대해 병렬 이분 탐색을 진행할 수 있다.</p>
<h2 id="음악-추천">음악 추천</h2>
<h3 id="입력">입력</h3>
<p>입력의 첫째 줄에는 세 정수로, 곡의 수 N(2 ≤ N ≤ 100,000), 추천 알고리즘의 결과 데이터의 수 K(1 ≤ K ≤ 100,000), 목표 점수 J(10 ≤ J ≤ 108)가 주어진다. 각각의 곡은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 N-1개의 곡 번호가 주어지는데, 이는 2번 곡부터 해당 곡의 부모 노드가 되는 곡의 번호이다. 1번 곡은 부모 노드가 없다. 다음 줄에 N개의 수가 주어지는데, 이는 1번 곡부터 해당 곡을 부른 가수의 번호이다. 가수의 번호는 1 이상 N 이하의 자연수이다. 다음 K개의 줄에 추천 알고리즘의 결과 데이터가 하나씩 주어진다. 결과 데이터는 T, P, S의 세 값으로 주어진다. T는 데이터가 계산된 시간으로, 1 이상 109 이하의 자연수이다. P는 점수가 부여되는 서브트리의 루트가 되는 곡의 번호이다. S는 서브트리에 부여할 가중치로, 1 이상 109 이하의 자연수이다.</p>
<h3 id="출력">출력</h3>
<p>출력은 N개의 줄로 이루어진다. 1번 곡부터 해당 곡을 부른 가수의 평균 점수가 J를 넘게 되는 시간을 출력한다. 점수가 J를 넘는 일이 없는 경우 -1을 출력한다. 같은 가수가 부른 곡은 같은 값을 가지게 될 것이다.</p>
<h3 id="코드">코드</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;algorithm&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;queue&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;map&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span><span style="color:#00f">typedef</span> <span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> ll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX = 100000 + 2, MAX_VALUE = 1e+9, MAX_J = 1e+8, MAX_T = 1e9 + 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> <span style="color:#2b91af">Query</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> t, p, s;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> <span style="color:#2b91af">Node</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> parent, index, artist, descendants;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> N, K, T, P, S, parent, n, artist, order[MAX], lo[MAX], hi[MAX], answer[MAX];
</span></span><span style="display:flex;"><span>ll seg[4 * MAX], lazy[4 * MAX], score[MAX], J;
</span></span><span style="display:flex;"><span>Node tree[MAX];
</span></span><span style="display:flex;"><span>Query queries[MAX];
</span></span><span style="display:flex;"><span>vector&lt;<span style="color:#2b91af">int</span>&gt; children[MAX], pbs[MAX], songs[MAX];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">void</span> update_lazy(<span style="color:#2b91af">int</span> node, <span style="color:#2b91af">int</span> left, <span style="color:#2b91af">int</span> right) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (lazy[node] == 0) <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>	seg[node] += (right - left + 1) * lazy[node];
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (left != right) {
</span></span><span style="display:flex;"><span>		lazy[node * 2] += lazy[node];
</span></span><span style="display:flex;"><span>		lazy[node * 2 + 1] += lazy[node];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	lazy[node] = 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll update(<span style="color:#2b91af">int</span> lo, <span style="color:#2b91af">int</span> hi, ll value, <span style="color:#2b91af">int</span> node, <span style="color:#2b91af">int</span> left, <span style="color:#2b91af">int</span> right) {
</span></span><span style="display:flex;"><span>	update_lazy(node, left, right);
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (right &lt; lo || hi &lt; left) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> seg[node];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (lo &lt;= left &amp;&amp; right &lt;= hi) {
</span></span><span style="display:flex;"><span>		lazy[node] += value;
</span></span><span style="display:flex;"><span>		update_lazy(node, left, right);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> seg[node];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> mid = (left + right) / 2;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> seg[node] = update(lo, hi, value, 2 * node, left, mid) + update(lo, hi, value, 2 * node + 1, mid + 1, right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll sum(<span style="color:#2b91af">int</span> lo, <span style="color:#2b91af">int</span> hi, <span style="color:#2b91af">int</span> node, <span style="color:#2b91af">int</span> left, <span style="color:#2b91af">int</span> right) {
</span></span><span style="display:flex;"><span>	update_lazy(node, left, right);
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (right &lt; lo || hi &lt; left) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (lo &lt;= left &amp;&amp; right &lt;= hi) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> seg[node];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> mid = (left + right) / 2;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> sum(lo, hi, 2 * node, left, mid) + sum(lo, hi, 2 * node + 1, mid + 1, right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> dfs(<span style="color:#2b91af">int</span> cur) {
</span></span><span style="display:flex;"><span>	order[cur] = ++n;
</span></span><span style="display:flex;"><span>	tree[cur].index = n;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#00f">auto</span> child : children[cur]) {
</span></span><span style="display:flex;"><span>		tree[cur].descendants += dfs(child);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> tree[cur].descendants + 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//FAST IO
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cin &gt;&gt; N &gt;&gt; K &gt;&gt; J;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 2; i &lt;= N; i++) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; parent;
</span></span><span style="display:flex;"><span>		tree[i].parent = parent;
</span></span><span style="display:flex;"><span>		children[parent].push_back(i);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 1; i &lt;= N; i++) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; artist;
</span></span><span style="display:flex;"><span>		songs[artist].push_back(i);
</span></span><span style="display:flex;"><span>		tree[i].artist = artist;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; K; i++) {
</span></span><span style="display:flex;"><span>		cin &gt;&gt; T &gt;&gt; S &gt;&gt; P;
</span></span><span style="display:flex;"><span>		queries[i] = { T, P, S };
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	sort(queries, queries + K, [](<span style="color:#00f">const</span> Query&amp; lv, <span style="color:#00f">const</span> Query&amp; rv) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">return</span> lv.t &lt; rv.t;
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dfs(1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fill(answer, answer + N + 1, MAX_T);
</span></span><span style="display:flex;"><span>	fill(hi, hi + N + 1, K - 1);
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">bool</span> flag = true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (flag) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		fill(score, score + MAX, 0);
</span></span><span style="display:flex;"><span>		fill(seg, seg + MAX * 4, 0);
</span></span><span style="display:flex;"><span>		fill(lazy, lazy + MAX * 4, 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> artist = 1; artist &lt;= N; artist++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> (songs[artist].size() &amp;&amp; lo[artist] &lt;= hi[artist]) {
</span></span><span style="display:flex;"><span>				pbs[(lo[artist] + hi[artist]) / 2].push_back(artist);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		flag = false;
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 0; i &lt; K; i++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">auto</span> [t, p, s] = queries[i];
</span></span><span style="display:flex;"><span>			<span style="color:#2b91af">int</span> root = order[s];
</span></span><span style="display:flex;"><span>			<span style="color:#2b91af">int</span> length = tree[s].descendants;
</span></span><span style="display:flex;"><span>			update(root, root + length, p / (length + 1), 1, 1, N);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#00f">while</span> (!pbs[i].empty()) {
</span></span><span style="display:flex;"><span>				<span style="color:#2b91af">int</span> artist = pbs[i].back(); pbs[i].pop_back();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#00f">for</span> (<span style="color:#00f">auto</span> song : songs[artist]) {
</span></span><span style="display:flex;"><span>					<span style="color:#2b91af">int</span> index = tree[song].index;
</span></span><span style="display:flex;"><span>					score[artist] += sum(index, index, 1, 1, N);
</span></span><span style="display:flex;"><span>					<span style="color:#008000">//if (score[artist] / songs[artist].size() &gt; J) break;
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				ll target = J * songs[artist].size();
</span></span><span style="display:flex;"><span>				<span style="color:#00f">if</span> (target &lt; score[artist]) {
</span></span><span style="display:flex;"><span>					answer[artist] = min(answer[artist], queries[i].t);
</span></span><span style="display:flex;"><span>					hi[artist] = i - 1;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>					lo[artist] = i + 1;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				flag = true;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 1; i &lt;= N; i++) {
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> flag = answer[tree[i].artist] != MAX_T;
</span></span><span style="display:flex;"><span>		cout &lt;&lt; (flag ? answer[tree[i].artist] : -1) &lt;&lt; <span style="color:#a31515">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</content>
<p>
  
  <a href="http://localhost:1313/blog/algorithm/">#Algorithm</a>
  
  <a href="http://localhost:1313/blog/traversal/">#Traversal</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
