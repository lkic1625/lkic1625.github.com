<!DOCTYPE html>
<html lang="ko-kr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>bipartite matching | Hammer&#39;s Blog</title>
<meta name="title" content="bipartite matching" />
<meta name="description" content="
Bipartite Matching(이분 매칭)
1. Graph Mathcing
Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다.
아래 사진은 올바른 매칭이 진행되었을 때 결과이다.

이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다.
하지만 가장 General한 Mathcing 알고리즘은 꽤나 복잡하여 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.
2. 이분매칭
이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다.
이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다." />
<meta name="keywords" content="network flow,algorithm," />


<meta property="og:url" content="http://localhost:1313/bipartite-matching/">
  <meta property="og:site_name" content="Hammer&#39;s Blog">
  <meta property="og:title" content="bipartite matching">
  <meta property="og:description" content="Bipartite Matching(이분 매칭) 1. Graph Mathcing Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다. 아래 사진은 올바른 매칭이 진행되었을 때 결과이다.
이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다. 하지만 가장 General한 Mathcing 알고리즘은 꽤나 복잡하여 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.
2. 이분매칭 이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다. 이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다.">
  <meta property="og:locale" content="ko_kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:tag" content="Network Flow">
    <meta property="article:tag" content="Algorithm">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="bipartite matching">
  <meta name="twitter:description" content="Bipartite Matching(이분 매칭) 1. Graph Mathcing Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다. 아래 사진은 올바른 매칭이 진행되었을 때 결과이다.
이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다. 하지만 가장 General한 Mathcing 알고리즘은 꽤나 복잡하여 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.
2. 이분매칭 이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다. 이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다.">




  <meta itemprop="name" content="bipartite matching">
  <meta itemprop="description" content="Bipartite Matching(이분 매칭) 1. Graph Mathcing Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다. 아래 사진은 올바른 매칭이 진행되었을 때 결과이다.
이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다. 하지만 가장 General한 Mathcing 알고리즘은 꽤나 복잡하여 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.
2. 이분매칭 이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다. 이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다.">
  <meta itemprop="wordCount" content="888">
  <meta itemprop="keywords" content="Network Flow,Algorithm">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f5f5f5;
      --code-color: #333;
      --blockquote-color: #222;
      --pre-border-color: #eee;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #1a1a1a;
          --code-color: #ddd;
          --blockquote-color: #ccc;
          --pre-border-color: #333;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding: 2px 4px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      font-size: 0.9em;
  }

  pre {
      background-color: var(--code-background-color) !important;
      border: 1px solid var(--pre-border-color);
      border-radius: 4px;
      padding: 1em;
      overflow-x: auto;
      margin: 1em 0;
  }

  pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--code-color);
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

   
  .highlight, .code, div.highlight {
      background-color: var(--code-background-color) !important;
      color: var(--code-color);
      border-radius: 4px;
      margin: 1em 0;
      overflow-x: auto;
      border: 1px solid var(--pre-border-color);
  }

  .highlight pre, .code pre {
      padding: 1em;
      margin: 0;
      overflow-x: auto;
      border: none;
      background-color: var(--code-background-color) !important;
  }

   
  .highlight, .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .chroma {
      background-color: var(--code-background-color) !important;
  }

   
  .highlight .k, .highlight .kd, .highlight .kn, .highlight .kr, .chroma .k, .chroma .kd, .chroma .kn, .chroma .kr {
      color: #569cd6;  
  }

  .highlight .s, .highlight .s1, .highlight .s2, .chroma .s, .chroma .s1, .chroma .s2 {
      color: #ce9178;  
  }

  .highlight .c, .highlight .c1, .highlight .cm, .chroma .c, .chroma .c1, .chroma .cm {
      color: #6a9955;  
  }

  .highlight .n, .highlight .nb, .highlight .nc, .chroma .n, .chroma .nb, .chroma .nc {
      color: var(--code-color);  
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true}
            ],
            
            throwOnError : false
        });
    });
</script> </head>

<body>
  <header><a href="/" class="title">
  <h2>Hammer&#39;s Blog</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>bipartite matching</h1>
<p>
  <i>
    <time datetime='0001-01-01'>
      01 Jan, 0001
    </time>
  </i>
</p>

<content>
  <script type="text/javascript"
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
<h1 id="bipartite-matching이분-매칭">Bipartite Matching(이분 매칭)</h1>
<h2 id="1-graph-mathcing">1. Graph Mathcing</h2>
<p>Graph의 Mathcing이란 단순 그래프가 주어졌을 때 끝점을 공유하지 않는 간선의 집합을 표현하는 방법이다.
아래 사진은 올바른 매칭이 진행되었을 때 결과이다.</p>
<p><img src="/assets/images/matching.png" alt="그래프 이미지"></p>
<p>이 때 가장 큰 매칭을 찾아내는 문제를 최대 매칭 문제라고한다.
하지만 가장 General한 Mathcing 알고리즘은 <a href="https://en.wikipedia.org/wiki/Blossom_algorithm">꽤나 복잡하여</a> 알고리즘 대회에서는 좀 더 단순한 형태로 등장하게 된다.</p>
<h2 id="2-이분매칭">2. 이분매칭</h2>
<p>이분 그래프란 정점을 두 그룹으로 나누어 모든 간선이 서로 다른 그룹의 정점들을 연결하도록 할 수 있는 그래프다.
이분 그래프는 두 집합의 대응 관계를 표현하기 위해 흔히 사용된다.</p>
<p>작업 분담, 사람을 짝짓는 방법 등 현실세계에서 직관적인 의미를 가지기 때문에 이분 매칭은 매칭 알고리즘 중에서 따로 언급할 가치가 있다.</p>
<h2 id="3-구현">3. 구현</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX_N = 1000, MAX_M = 1000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">//A와 B의 정점의 개수
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#2b91af">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#008000">//인접리스트
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#2b91af">bool</span> adj[MAX_N][MAX_M];
</span></span><span style="display:flex;"><span><span style="color:#008000">//각 정점에 매칭된 상대 정점의 번호를 저장한다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>vector&lt;<span style="color:#2b91af">int</span>&gt; aMatch, bMatch;
</span></span><span style="display:flex;"><span><span style="color:#008000">//dfs 방문 여부
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>vector&lt;<span style="color:#2b91af">bool</span>&gt; visited;
</span></span><span style="display:flex;"><span><span style="color:#008000">//A의 정점인 a에서 B의 매칭되지 않은 정점으로 가는 경로를 찾는다.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#2b91af">bool</span> dfs(<span style="color:#2b91af">int</span> a) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (visited[a]) <span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>	visited[a] = true;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> b = 0; b &lt; m; b++) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (adj[a][b]) {<span style="color:#008000">//b가 이미 매칭되어 있다면 bMatch[b]에서부터 시작해 증가경로를 찾는다
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>			<span style="color:#00f">if</span> (bMatch[b] == -1 || dfs(bMatch[b])) {
</span></span><span style="display:flex;"><span>				<span style="color:#008000">//증가 경로를 발견할 경우 a와 b를 매치 시킨다
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>				aMatch[a] = b;
</span></span><span style="display:flex;"><span>				bMatch[b] = a;
</span></span><span style="display:flex;"><span>				<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> bipartiteMatch() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//처음에는 정점이 모두 연결되어 있지 않음.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	aMatch = vector&lt;<span style="color:#2b91af">int</span>&gt;(n, -1);
</span></span><span style="display:flex;"><span>	bMatch = vector&lt;<span style="color:#2b91af">int</span>&gt;(m, -1);
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> size = 0;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> start = 0; start &lt; n; start++) {
</span></span><span style="display:flex;"><span>		visited = vector&lt;<span style="color:#2b91af">bool</span>&gt;(n, false);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (dfs(start))
</span></span><span style="display:flex;"><span>			++size;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> size;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>포드-풀커슨 알고리즘을 통해 이분 매칭을 구현할 수도 있지만, 이분 매칭 문제는 일반적인 네트워크 유량 문제보다 비교적 자주 출현하기 때문에 좀 더 간단한 형식의 코드를 작성해둘 필요가 있다.</p>
<p>작성된 코드는 이분매칭의 관련된 속성으로 인해 동작한다.</p>
<ol>
<li>최대 유량이 $$O(\left\lvert V \right\rvert)$$로 고정된다. 포드 풀커슨 알고리즘을 이용한 구현은 수행시간이 최대 유량에 비례하므로, 깊이 우선 탐색을 사용하여도 될 것이다.</li>
<li>증가 경로를 찾기 위해 탐색하는 도중 B에 포함된 정점에 도착했는데 이 정점이 이미 매칭된 상황이라면, 증가 경로의 다음 간선은 유일하게 결정된다.</li>
</ol>
<ul>
<li>싱크로 나가는 간선 하나 밖에 없는 경우이고, 매칭된 상황에서는 이 간선의 잔여용량이 남아있지 않을 것이다.</li>
<li>이는 곧 매칭된 정점 A로 유량을 상쇄하는 방법 밖에 남지 않았다는 것이다.</li>
<li>따라서, b와 인접한 정점을 확인하는 것이 아니라 매칭된 a를 곧장 재귀호출 하는 부분은 위와 같은 속성을 이용한 것이다.</li>
</ul>
<h2 id="4-문제-bishops">4. 문제 BISHOPS</h2>
<p>링크: <a href="https://algospot.com/judge/problem/read/BISHOPS">https://algospot.com/judge/problem/read/BISHOPS</a>
\</p>
<h3 id="input">input</h3>
<p>입력은 여러 개의 테스트 케이스로 주어진다. 입력의 첫 줄에는 테스트 케이스의 개수 $$T$$가 들어온다.
각각의 테스트 케이스의 첫 줄에는 체스판의 크기 $$N (1 \le N \le 8)$$이 주어진다.
이후 N줄에는 체스판의 상태가 주어진다. <code>.</code> 은 Bishop을 놓을 수 있는 곳이며, <code>*</code> 은 장애물이다.</p>
<h3 id="output">output</h3>
<p>각각의 테스트 케이스들에 대해 최대로 놓을 수 있는 Bishop의 개수를 출력한다.</p>
<h3 id="test-case">Test Case</h3>
<pre tabindex="0"><code>3
5
.....
.....
.....
.....
.....
8
..**.*.*
**.***.*
*.**...*
.*.**.**
*.**.*.*
..**.*.*
...*.*.*
**.*.*.*
8
*.*.*.*.
.*.*.*.*
*.*.*.*.
.*.*.*.*
*.*.*.*.
.*.*.*.*
*.*.*.*.
.*.*.*.*
</code></pre><pre tabindex="0"><code>8
18
7
</code></pre><h3 id="코드">코드</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include&lt;iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include&lt;string.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#2b91af">int</span> MAX_CHESS_BOARD_SIZE = 8, MAX = 100;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> T, N, n, m;
</span></span><span style="display:flex;"><span>string chessboard[MAX_CHESS_BOARD_SIZE + 2];
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> id[2][MAX_CHESS_BOARD_SIZE + 2][MAX_CHESS_BOARD_SIZE + 2], adj[MAX][MAX];
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> dy[2] = { 1, 1 }, dx[2] = { 1, -1 };
</span></span><span style="display:flex;"><span>vector&lt;<span style="color:#2b91af">int</span>&gt; match;
</span></span><span style="display:flex;"><span>vector&lt;<span style="color:#2b91af">bool</span>&gt; visited;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">bool</span> dfs(<span style="color:#2b91af">int</span> a) {
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> (visited[a]) <span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>	visited[a] = true;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> b = 1; b &lt; m; b++) {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (adj[a][b]) {<span style="color:#008000">//b가 매칭되어 있지 않거나 이미 매칭된 정점이 다른 정점과 매칭이 가능할 경우 bMatch[b]에서부터 시작해 증가경로를 찾는다
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>			<span style="color:#00f">if</span> (match[b] == -1 || dfs(match[b])) {
</span></span><span style="display:flex;"><span>				<span style="color:#008000">//증가 경로를 발견할 경우 a와 b를 매치 시킨다
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>				match[b] = a;
</span></span><span style="display:flex;"><span>			<span style="color:#008000">//	cout &lt;&lt; a &lt;&lt; &#34;와 &#34; &lt;&lt; b &lt;&lt; &#34;를 매칭시킵니다.&#34; &lt;&lt; endl;
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>				<span style="color:#00f">return</span> true;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> bipartiteMatch() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//처음에는 정점이 모두 연결되어 있지 않음.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>	match = vector&lt;<span style="color:#2b91af">int</span>&gt;(m, -1);
</span></span><span style="display:flex;"><span>	<span style="color:#2b91af">int</span> size = 0;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> start = 1; start &lt; n; start++) {
</span></span><span style="display:flex;"><span>		visited = vector&lt;<span style="color:#2b91af">bool</span>&gt;(n, false);
</span></span><span style="display:flex;"><span>		<span style="color:#00f">if</span> (dfs(start))
</span></span><span style="display:flex;"><span>			++size;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">void</span> binding() {
</span></span><span style="display:flex;"><span>	<span style="color:#008000">//starting number for each node is 1.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>	<span style="color:#2b91af">int</span> idx[2] = { 1, 1 };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> direction = 0; direction &lt; 2; direction++) {
</span></span><span style="display:flex;"><span>		<span style="color:#2b91af">int</span> visited[MAX_CHESS_BOARD_SIZE + 2][MAX_CHESS_BOARD_SIZE + 2];
</span></span><span style="display:flex;"><span>		memset(visited, false, <span style="color:#00f">sizeof</span>(visited));
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> y = 1; y &lt;= N; y++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> x = 1; x &lt;= N; x++) {
</span></span><span style="display:flex;"><span>				<span style="color:#2b91af">int</span> cy = y, cx = x;
</span></span><span style="display:flex;"><span>				<span style="color:#008000">//verify that we have not visited, and can create nodes
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>				<span style="color:#00f">while</span> (chessboard[cy][cx] != <span style="color:#a31515">&#39;*&#39;</span> &amp;&amp; !visited[cy][cx]) {
</span></span><span style="display:flex;"><span>					visited[cy][cx] = true;
</span></span><span style="display:flex;"><span>					<span style="color:#008000">//numbering
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>					id[direction][cy][cx] = idx[direction];
</span></span><span style="display:flex;"><span>					cy += dy[direction];
</span></span><span style="display:flex;"><span>					cx += dx[direction];
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				idx[direction]++;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	n = idx[0];
</span></span><span style="display:flex;"><span>	m = idx[1];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main() {
</span></span><span style="display:flex;"><span>	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cin &gt;&gt; T;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">while</span> (T-- &gt; 0) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//input
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		cin &gt;&gt; N;		
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> i = 1; i &lt;= N; i++) {
</span></span><span style="display:flex;"><span>			cin &gt;&gt; chessboard[i];
</span></span><span style="display:flex;"><span>			chessboard[i] = <span style="color:#a31515">&#34;*&#34;</span> + chessboard[i] + <span style="color:#a31515">&#34;*&#34;</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//init
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		chessboard[N + 1] = <span style="color:#a31515">&#34;**********&#34;</span>;
</span></span><span style="display:flex;"><span>		chessboard[0] = <span style="color:#a31515">&#34;**********&#34;</span>;
</span></span><span style="display:flex;"><span>		memset(adj, 0, <span style="color:#00f">sizeof</span>(adj));
</span></span><span style="display:flex;"><span>		memset(id, 0, <span style="color:#00f">sizeof</span>(id));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//creating nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		binding();
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//connecting edges.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> y = 1; y &lt;= N; y++) {
</span></span><span style="display:flex;"><span>			<span style="color:#00f">for</span> (<span style="color:#2b91af">int</span> x = 1; x &lt;= N; x++) {
</span></span><span style="display:flex;"><span>				<span style="color:#00f">if</span> (chessboard[y][x]) {
</span></span><span style="display:flex;"><span>					adj[id[0][y][x]][id[1][y][x]] = 1;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//bipartite matching
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		<span style="color:#2b91af">int</span> Answer = bipartiteMatch();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#008000">//output
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>		cout &lt;&lt; Answer &lt;&lt; <span style="color:#a31515">&#34;</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="핵심-아이디어">핵심 아이디어</h3>
<p>문제의 핵심이 되는 접근법은 대각선 방향으로 체스판을 묶는 것이다.
아래 그림과 같이 체스판을 묶을 경우 빈칸은 두 종류의 대각선 방향으로 나타낼 수 있다.</p>
<p><img src="/assets/images/bishops.PNG" alt="그림"></p>
<p>따라서, 이와 같이 그래프를 구성할 경우 비숍을 놓는다 == 두 묶음을 서로 대응시킨다로 나타낼 수 있다.</p>
<blockquote>
<p><font size="6">Refernce</font></p></blockquote>
<ul>
<li>구종만 지음, 알고리즘 문제 해결 전략, 인사이트, 32장</li>
</ul>

</content>
<p>
  
  <a href="http://localhost:1313/blog/network-flow/">#Network Flow</a>
  
  <a href="http://localhost:1313/blog/algorithm/">#Algorithm</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
