<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-29T00:24:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">untitled</title><subtitle>기록용 블로그입니다. 개발관련 게시글을 주로 올립니다.</subtitle><author><name>조원빈</name></author><entry><title type="html">동기, 비동기, 블록킹 그리고 논 블록킹</title><link href="http://localhost:4000/js/Blocking_NonBlocking_Synchronous_Asynchronous/" rel="alternate" type="text/html" title="동기, 비동기, 블록킹 그리고 논 블록킹" /><published>2020-11-28T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/js/Blocking_NonBlocking_Synchronous_Asynchronous</id><content type="html" xml:base="http://localhost:4000/js/Blocking_NonBlocking_Synchronous_Asynchronous/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;최근 꽤나 오래 일을 해오신 개발자 분도 둘의 차이를 모르는 것 같아 놀랐다. 꼭 구분해야할 것이라곤 생각 안 하지만 말의 미묘한 차이는 커뮤니케이션에도 치명적일 수 있으니 한 번 정리해보자.&lt;/p&gt;

&lt;p&gt;이번 포스트 주제는 말은 비슷해 보이지만 뭔가 다른 두 쌍에 대해 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;blockingnon-blocking&quot;&gt;Blocking/Non-Blocking&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blocking&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-blocking&lt;/code&gt; 호출되는 함수가 바로 리턴하는가에 차이다.&lt;/p&gt;

&lt;p&gt;호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른일을 할 수 있는 기회를 줄 수 있으면, 논블록킹이다.&lt;/p&gt;

&lt;p&gt;그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 블록킹이다.&lt;/p&gt;

&lt;h1 id=&quot;synchronousasynchronous&quot;&gt;Synchronous/Asynchronous&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Synchronous&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asynchronous&lt;/code&gt;는 호출되는 함수의 작업 완료 여부를 누가 신경쓰는가에 차이다.&lt;/p&gt;

&lt;p&gt;호출되는 함수에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback&lt;/code&gt;을 전달해서 호출되는 함수의 작업이 완료되면, 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asynchronous&lt;/code&gt;다.&lt;/p&gt;

&lt;p&gt;호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 스스로 확인하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Synchronous&lt;/code&gt;다.&lt;/p&gt;

&lt;h1 id=&quot;blocking-with-synchronous-non-blocking-with-asynchronous&quot;&gt;Blocking with Synchronous, Non-Blocking with Asynchronous&lt;/h1&gt;

&lt;p&gt;이와 같이 묶인 조합은 상당히 비슷한 동작을 진행하는 둘이기에 이해가 쉽다. 아래 그림을 참조하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ibm-devwokrs-2x2matrix.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;non-blocking-with-synchronous&quot;&gt;Non-Blocking with Synchronous&lt;/h1&gt;

&lt;p&gt;위에 정의대로라면 호출된 함수는 바로 리턴을 하지만, 호출한 함수가 작업 완료여부를 계속해서 확인하는 것이다. 작업 완료 전까지는 호출한 함수가 계속해서 물으며 진행은 못하지만 또 다른 작업을 진행할 수는 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/nonblocking_with_sync.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;blocking-with-asynchronous&quot;&gt;Blocking with Asynchronous&lt;/h1&gt;

&lt;p&gt;위에 정의대로라면 호출된 함수는 바로 리턴하지 않지만, 이에 대한 완료여부를 호출한 함수가 신경쓰지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blocking_with_sync.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고한 블로그에서는 이에대한 예시로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;의 조합을 언급했다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt; 쪽에서 callback 지옥을 헤치면서 Async로 전진해와도, 결국 DB 작업 호출 시에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;에서 제공하는 드라이버를 호출하게 되는데, 이 드라이버가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Blocking&lt;/code&gt; 방식이라고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blocking-Async는 별다른 장점이 없어서 일부러 사용할 필요는 없지만, NonBlocking-Async 방식을 쓰는데 그 과정 중에 하나라도 Blocking으로 동작하는 놈이 포함되어 있다면 의도하지 않게 Blocking-Async로 동작할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="js" /><category term="os" /><category term="sync" /><summary type="html">Introduction</summary></entry><entry><title type="html">Node.js 이벤트 루프(작성중)</title><link href="http://localhost:4000/nodejs/node_event_loop/" rel="alternate" type="text/html" title="Node.js 이벤트 루프(작성중)" /><published>2020-11-28T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/nodejs/node_event_loop</id><content type="html" xml:base="http://localhost:4000/nodejs/node_event_loop/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;를 통해 개발하면서 사용할 줄만 알았지 제대로 된 개념하나 안 잡힌 것 같아 포스트를 작성한다. 이벤트 루프에 대해 알아보자. 블로그에서 최근 작성한 글 중에서 가장 긴 글이 되지 않을까 싶다.&lt;/p&gt;

&lt;h1 id=&quot;event-loop&quot;&gt;Event Loop&lt;/h1&gt;

&lt;p&gt;자바스크립트는 알다 싶이 단일 스레드 기반의 언어다. 단일 쓰레드라는 의미는 들어오는 작업에 대해 순차적으로, 동시성을 지원하지 못하는 순차적인 실행 구조를 가졌다는 의미다.&lt;/p&gt;

&lt;p&gt;하지만, 우리는 JS로 비동기와 관련된 여러 기능들을 자유롭게 사용할 수 있다. 이는 어떻게 가능한 것일까?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이때 등장하는 개념이 바로 ‘이벤트 루프’이다. Node.js를 소개할 때 ‘이벤트 루프 기반의 비동기 방식으로 Non-Blocking IO를 지원하고..’ 와 같은 문구를 본 적이 있을 것이다. 즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/event_loop_node_js.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이벤트 루프에 대해 알아보기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt; 내부로 들어가보려 한다. 보다 자세한 설명은 너무나도 친절하게 쓰여진 &lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;공식문서&lt;/a&gt;에서 확인할 수 있다. 시간이 남는다면 읽는 것을 추천한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node.js&lt;/code&gt; 이벤트 루프에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phase&lt;/code&gt; 단위로 나뉘어져 있다. 이벤트 루프를 쉽게 설명하기 위해 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;만을 사용한 그림 등을 본적이 있겠지만, 이는 너무 포괄적인 개요가 아닌가 싶다.&lt;/p&gt;

&lt;p&gt;각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phase&lt;/code&gt;는 저마다 특정 작업을 실행하며, 콜백을 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIFO Queue&lt;/code&gt;를 가지고 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idle, prepare&lt;/code&gt; 페이즈를 제외한 어느 단계에서나 자바스크립트 실행이 일어나며, 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;phase&lt;/code&gt;에 존재하는 대기열을 모두 소진하거나 그 페이즈에서 실행할 수 있는 콜백의 최대 수를 넘었을 경우에 다음 페이즈로 진행한다.&lt;/p&gt;

&lt;h2 id=&quot;phases-overview&quot;&gt;Phases Overview&lt;/h2&gt;

&lt;h3 id=&quot;timers&quot;&gt;timers&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setInterval&lt;/code&gt;에 의해 스케쥴된 콜백을 실행하는 페이즈다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;은 만료 후 가능한한 빨리 실행되어야 하는 콜백을 가진다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay&lt;/code&gt;를 파라미터로 줄 수 있다. 여기서 알아둬야할 것은 딜레이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0ms&lt;/code&gt;로 줄 수 없다는 것이다. 내부적으로 타이머의 최소단위를 지정하기 때문에 그 최소단위만큼 지난 후에 태스크 큐에 추가된다.&lt;/p&gt;

&lt;p&gt;“즉시”라는 의미를 충족시키기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;가 제안되었다. 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll phase&lt;/code&gt;가 끝난 뒤 즉시 시작하도록 설계된 함수다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;는 안타깝게도 표준 반열에 오르지 못하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IE10&lt;/code&gt; 이상에만 포함되었는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;에는 이런 용도를 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextTick&lt;/code&gt;라는 함수가 존재한다. 자세한 내용은 추후 설명하겠다.&lt;/p&gt;

&lt;h3 id=&quot;pending-callbacks&quot;&gt;pending callbacks&lt;/h3&gt;

&lt;p&gt;이전 루프에서 연기된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I/O callback&lt;/code&gt;을 실행한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending_queue&lt;/code&gt; 들어와 있는 콜백들은 현재 돌고 있는 루프 이전에 한 작업에서 이미 큐에 들어왔던 콜백이다. 예를들어 TCP 핸들러 콜백 함수에서 파일에뭔가 썼다면, TCP 통신과 파일 쓰기가 종료 후 파일 쓰기에 대한 콜백이 이 큐에 들어오는 것이다.&lt;/p&gt;

&lt;p&gt;또한, 에러 콜백도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending_queue&lt;/code&gt;에 들어온다.&lt;/p&gt;

&lt;h3 id=&quot;idle-prepare&quot;&gt;idle, prepare&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#phases-overview&quot;&gt;내부적으로 사용한다.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;poll-phase&quot;&gt;Poll phase&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I/O 콜백&lt;/code&gt;을 허용한다. 예로들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.readFile&lt;/code&gt;에 넘겨준 콜백인자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I/O&lt;/code&gt; 작업이 끝난 후에 실행된다.&lt;/p&gt;

&lt;p&gt;평소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll queue(watcher_queue)&lt;/code&gt;가 비어있다면, 곧바로 페이즈로 넘어가는 것이 아니라 약간에 대기시간을 가지고 콜백이 들어오면 바로 실행한다.&lt;/p&gt;

&lt;p&gt;이 대기시간은 아래서 설명하겠지만, 기준은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timer queue&lt;/code&gt;에 콜백의 존재 유무다.&lt;/p&gt;

&lt;h3 id=&quot;check-phase&quot;&gt;Check phase&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;만을 위한 페이즈다. 추후 설명하겠다.&lt;/p&gt;

&lt;h3 id=&quot;close-callbacks&quot;&gt;Close callbacks&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.on('close', () =&amp;gt;{})&lt;/code&gt;과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt; 이벤트 타입의 헨들러가 여기서 처리된다.&lt;/p&gt;

&lt;h2 id=&quot;microtasks-nexttick&quot;&gt;Microtasks, NextTick?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Microtasks&lt;/code&gt;란 다음 페이즈로 넘어가기 전에 반드시 실행되어야 할 콜백이다. 예로는 프로미스의 Resolve된 콜백이 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextTick&lt;/code&gt; 0.9버전 이상의 노드에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Microtasks&lt;/code&gt;를 이용하도록 변경되었다. 자세한 설명은 이 포스트에서 하긴 어려울 것 같다. &lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick&quot;&gt;공식문서&lt;/a&gt;에서 확인하길 바란다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 콜백을 담당하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextTickQueue와&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;microTaskQueue&lt;/code&gt;라 불린다.&lt;/p&gt;

&lt;p&gt;위에 나온 그림에서도 얼핏 눈치챘을지 모르지만, 위 둘은 이벤트 루프에 일부가 아니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libUV&lt;/code&gt; 라이브러리에 포함된 것이 아닌 노드에 포함된 기술이라는 의미다.&lt;/p&gt;

&lt;p&gt;위 큐에 적재되어있는 작업은 반드시 현재 작업이 끝나자마자 바로 호출되어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;libUV는 Node.js에서 사용하는 비동기 I/O 라이브러리이다. 이 라이브러리는 C로 작성되었고 윈도우나 리눅스 커널을 추상화해서 Wrapping하고 있는 구조이다. 즉, 커널에서 어떤 비동기 작업들을 지원해주는 지 알고 있기 때문에 커널을 사용하여 처리할 수 있는 비동기 작업을 발견하면 바로 커널로 작업을 넘겨버린다.
&lt;br /&gt;
이후 이 작업들이 종료되어 OS 커널로부터 시스템 콜을 받으면 이벤트 루프에 콜백을 등록하는 것이다. 만약 OS 커널이 지원하지 않는 작업일 경우 별도의 스레드에 작업을 던져서 처리한다. 이 스레드에 관한 내용은 원작자가 밑에서 추가적으로 설명하고있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;microtasks와 일반 task, Scheduled와 관련해 인터랙션과 함께 잘 정리된 글이 있어 아래 링크를 남긴다. 이 포스트와 함께 읽는다면 좋을 것 같다. https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;event-loop-phases-in-more-detail&quot;&gt;Event loop phases in more detail&lt;/h2&gt;

&lt;p&gt;개요가 너무 길었다 자세하게 알아보자.&lt;/p&gt;

&lt;p&gt;우선 우리가 실행하려는 자바스크립트 파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello.js&lt;/code&gt;을 보자. 콘솔에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node hello.js&lt;/code&gt;를 입력한다면 노드는 이벤트 루프를 생성 후 루프 바깥에서 메인 모듈인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello.js&lt;/code&gt;를 실행한다. 한 번 메인 모듈이 실행된 후에 노드는 이벤트 루프에서 처리해야할 작업이 있다면 루프로 들어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timer phase&lt;/code&gt;부터 시작한다. 만약 없다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process.on('exit', foo)&lt;/code&gt; 종료 콜백을 실행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/nodejs-event-loop-workflow.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;timer-phase&quot;&gt;Timer Phase&lt;/h3&gt;

&lt;p&gt;이벤트 페이즈가 타이머 페이즈에 들어가게 되면 실행할 타이머 콜백 큐를 탐색한다. 사실, 앞에서 각 페이즈에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIFO Queue&lt;/code&gt;가 존재한다 하였다. 이는 큐에 들어있는 작업의 포지션을 절대 변경하지 않는다는 것이다. 무조건 큐에 먼저 들어간 작업이 먼저 실행된다. 또한, 이를 실질적으로 감리감독하는 자료구조의 실체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min heap&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;느슨한 순서로 저장된 자료구조 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min heap&lt;/code&gt;에서 특정 시점 콜백이 실행시간을 만족하는지 확인한다. 만약 만족하지 못할 경우 이후 콜백은 확인할 필요가 없다.(정렬되어 있으니)&lt;/p&gt;

&lt;h3 id=&quot;pending-io-phase&quot;&gt;Pending I/O Phase&lt;/h3&gt;

&lt;p&gt;타임 페이즈가 종료된 후 이벤트 루프는 펜딩 I/O 페이즈에 진입한다. 가장 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending queue&lt;/code&gt;에 이전 작업들의 콜백이 실행 대기 중인지 확인한다. 만약 실행 대기 중이라면, 대기열이 소진되거나 시스템의 실행 한도를 초과할 때까지 콜백을 실행한다. 이 과정이 종료되면 이벤트 루프는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Idle Handler Phase&lt;/code&gt;로 이동한 후 내부 처리를 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prepare Phase&lt;/code&gt;를 거쳐 최종적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll Phase&lt;/code&gt;에 도달하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;poll-phase-1&quot;&gt;Poll Phase&lt;/h3&gt;

&lt;p&gt;이 페이즈는 폴링을 진행하는 단계다. 이벤트 루프가 이 페이즈에 들어왔을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;polling queue(watcher_queue)&lt;/code&gt; 내부파일 읽기에 대한 콜백, HTTP 응답 콜백과 같은 작업이 존재하며, 시스템 한도 내에서 이를 실행시킨다.&lt;/p&gt;

&lt;p&gt;만약 더 이상 실행할 콜백이 없다면,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check_queue&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending_queue&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closing_callbacks_queue에&lt;/code&gt; 해야할 작업이 있는지를 검사하고, 만약 해야할 작업이 있다면 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll phase가&lt;/code&gt; 종료되고 다음 페이즈로 넘어가게 된다. 하지만 특별히 해야할 작업이 더 이상 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll phase&lt;/code&gt;는 다음 페이즈로 넘어가지 않고 계속 대기하게 된다.
ㅔㅔ
대기시간에 제약은 아래 알고리즘을 따른다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Check Phase&lt;/code&gt;에 실행할 콜백이 있는가?&lt;/li&gt;
  &lt;li&gt;없다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timer&lt;/code&gt;에 있는가? -&amp;gt; 타이머 페이즈가 실행 가능한 시간까지 대기 후 타이머 페이즈로 간다.&lt;/li&gt;
  &lt;li&gt;없다면 대기&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;check-phases&quot;&gt;Check Phases&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Poll Phase&lt;/code&gt;가 지나면 이벤트 루프의 다음 목적지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 콜백과 관련있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Check phase&lt;/code&gt;로 들어온다. 이 페이즈에선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;의 콜백을 실행한다. 다른 페이즈와 마찬가지로 큐가 비거나 시스템 실행 한도 초과에 도달할 때까지 계속 해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt; 콜백들을 실행한다.&lt;/p&gt;

&lt;h3 id=&quot;close-phase&quot;&gt;Close Phase&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destroy&lt;/code&gt;를 관리하는 페이즈다.&lt;/p&gt;

&lt;p&gt;이벤트 루프가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close callback&lt;/code&gt;들과 함께 종료하면, 이벤트 루프는 다음에 돌아야할 루프가 존재하는지 확인한다. 만약 아니라면 이벤트 루프는 종료하게 된다. 수행할 것이 남아있으면 이벤트 루프 순회를 돌며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timer phase&lt;/code&gt; 부터 다시 시작하게 된다.&lt;/p&gt;

&lt;h1 id=&quot;example&quot;&gt;Example&lt;/h1&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic&lt;/h2&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;이 반드시 앞에 올거라는 확신을 할 수 있을까?&lt;/p&gt;

&lt;p&gt;타이머는 시스템 시간과 사용자 제공 시간을 사용하여 등록한다. 이는 어떤 의미일까? 좀 더 자세하게 이야기하면 타이머는 메모리에 현재 타이머를 저장하게 된다. 그 순간 컴퓨터 성능이나 다른 외부 작업에 의해 약간의 딜레이가 발생할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;또 다른 포인트는 노드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timer phase&lt;/code&gt;에 진입하기전에 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;now&lt;/code&gt;를 선언하고 그 변수를 현재시간으로 간주한다는 점이다. 그러므로 정확한 계산이라고 하기에는 약간의 노이즈가 껴있고, 이게 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;이 반드시 먼저 실행될 것이라고 확신할 수 없는 불확실성의 이유가 된다.&lt;/p&gt;

&lt;p&gt;하지만, 아래와 같은 코드처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I/O 콜백&lt;/code&gt; 사이클 내부로 옮긴다면 반드시 순서를 보장할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;my-file-path.txt&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;순서대로 코드가 실행되는 동작을 확인하겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs.readFile&lt;/code&gt;을 만나면 이벤트 루프는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libUV&lt;/code&gt;에게 해당 작업을 보낸다.&lt;/li&gt;
  &lt;li&gt;파일 읽기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OS Kernel&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asynchronous API&lt;/code&gt;를 제공하지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libUV&lt;/code&gt;는 별도의 스레드에 해당 작업을 던진다.&lt;/li&gt;
  &lt;li&gt;작업이 완료되면 이벤트 루프는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pending I/O callback phase&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pending_queue&lt;/code&gt;에 작업의 콜백을 등록한다.&lt;/li&gt;
  &lt;li&gt;이벤트 루프가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pending Phase&lt;/code&gt;를 지날 때 해당 콜백을 실행한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;의 콜백이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timer Phase&lt;/code&gt; 큐에 등록된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;의 콜백이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chekc Phase&lt;/code&gt;에 등록된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate를&lt;/code&gt; 콘솔에 출력한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout을&lt;/code&gt; 콘솔에 출력한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;timer에-이해&quot;&gt;Timer에 이해&lt;/h2&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Execution time: &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예시에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;를 1000번 재귀호출한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Execution time: &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout(foo, 0)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate(foo)&lt;/code&gt;는 놀랍게도 시간차이가 상당하다. 어째서일까? 정답은 시간을 비교하고 편차를 알아내는 작업이 CPU 연산을 상대적으로 많이 사용하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;는 이러한 작업이 필요없기 때문에 상대적으로 매우 빠르다.&lt;/p&gt;

&lt;h1 id=&quot;faq&quot;&gt;FAQ&lt;/h1&gt;

&lt;h2 id=&quot;이벤트-루프는-자바스크립트-엔진-내부에-있나&quot;&gt;이벤트 루프는 자바스크립트 엔진 내부에 있나?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECMAScript&lt;/code&gt;에는 이벤트 루프가 없다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ES6&lt;/code&gt;부터는 여러가지 지원하는 것들이 늘어났지만 기본적으로 자바스크립트 엔진 내부에 없으며, 이를 구동하는 환경인 웹브라우저나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;에서 담당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/js_inner.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서도 볼 수 있듯이 실제로 우리가 비동기 호출에 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;과 같은 함수들이 엔진 내부가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web API&lt;/code&gt; 영역에 따로 정의되어 있다.&lt;/p&gt;

&lt;p&gt;예를들어 보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;는 비동기 지원을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libuv&lt;/code&gt;에서 제공하는 이벤트 루프를 통해 실현시켰다. 자바스크립트 엔진은 비동기 작업을 위해 내부 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;를 호출하고 내부에 존재하는 이벤트 루프를 통해 스케쥴 되고 실행되는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-이벤트-루프는-어디서-실행되는데&quot;&gt;그래서 이벤트 루프는 어디서 실행되는데?&lt;/h2&gt;

&lt;p&gt;자바스크립트와 이벤트 루프는 다른 쓰레드를 통해 독립적으로 실행되는 것이 아니라. 이벤트 루프 자체에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V8&lt;/code&gt; 혹은 다른 엔진을 사용하여 자바스크립트를 실행하는 것이다. 단 하나의 쓰레드를 사용하여 자바스크립트는 실행된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;실행 자체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Synchronous&lt;/code&gt; 하며, 자바스크립트가 실행되지 않는다면 이벤트 루프 또한 진행되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;nexttickqueue과-microtaskqueue의-실행-시기는-언제인가&quot;&gt;nextTickQueue과 microTaskQueue의 실행 시기는 언제인가?&lt;/h2&gt;

&lt;p&gt;즉시 실행되기를 바라는 두 큐는 언제 실행될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/nodejs-event-loop-workflow.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IBM developer&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt; 이벤트 루프에 대한 글에선 아래와 같이 설명하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Immediately after mainline finishes and after every phase of the event loop, the microtask callbacks run.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextTickQueue&lt;/code&gt; 또한 마찬가지이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextTickQueue는&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;microTaskQueue보다는&lt;/code&gt; 높은 우선 순위를 가지고 있다.&lt;/p&gt;

&lt;h1 id=&quot;글을-마치며&quot;&gt;글을 마치며..&lt;/h1&gt;

&lt;p&gt;오랜만에 좋은 블로그와 자료들을 찾아서 이를 나만의 방식으로 정리했다. 최근에 포스트를 단순히 옮겨적는 데에 치중했었는데 늘어졌던 자세를 바로잡는 기회가 되지 않았나 싶다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/&lt;/li&gt;
    &lt;li&gt;https://meetup.toast.com/posts/89&lt;/li&gt;
    &lt;li&gt;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&lt;/li&gt;
    &lt;li&gt;https://developer.ibm.com/tutorials/learn-nodejs-the-event-loop/&lt;/li&gt;
    &lt;li&gt;https://www.voidcanvas.com/nodejs-event-loop&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="nodejs" /><category term="js" /><category term="event_loop" /><summary type="html">Introduction</summary></entry><entry><title type="html">CORS(작성중)</title><link href="http://localhost:4000/backend/CORS/" rel="alternate" type="text/html" title="CORS(작성중)" /><published>2020-11-27T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/backend/CORS</id><content type="html" xml:base="http://localhost:4000/backend/CORS/">&lt;h1 id=&quot;cors란&quot;&gt;CORS란&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross Origin Resource Sharing(CORS)&lt;/code&gt;는 웹서버를 개발하다보면 자주 마주칠 수 있는 상황이다.&lt;/p&gt;

&lt;p&gt;이는 도메인 또는 포트가 다른 서버의 자원을 요청할 경우 보안상의 이유로 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한한다.&lt;/p&gt;

&lt;p&gt;API를 사용하는 웹 애플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있으며, 다른 출처의 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;functional-overview&quot;&gt;Functional Overview&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CORS&lt;/code&gt;는 웹 브라우저에서 해당 정보를 읽는 것이&lt;/p&gt;</content><author><name>조원빈</name></author><category term="backend" /><category term="backend" /><category term="serverless" /><summary type="html">CORS란</summary></entry><entry><title type="html">시계열 데이터 관측</title><link href="http://localhost:4000/database/redis_02/" rel="alternate" type="text/html" title="시계열 데이터 관측" /><published>2020-11-27T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/database/redis_02</id><content type="html" xml:base="http://localhost:4000/database/redis_02/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h1 id=&quot;time-series&quot;&gt;Time Series&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;시계열(時系列, 영어: time series)은 일정 시간 간격으로 배치된 데이터들의 수열을 말한다. 시계열 해석(time series analysis)라고 하는 것은 이런 시계열을 해석하고 이해하는 데 쓰이는 여러 가지 방법을 연구하는 분야이다.
-wikipedia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시계열 데이터는 다양한 분석방법에 쓰일 수 있으며, 아래는 이에 대한 예시이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Usage of specific words or terms in a newspaper over time&lt;/li&gt;
  &lt;li&gt;Minimum wage year-by-year&lt;/li&gt;
  &lt;li&gt;Daily changes in stock prices&lt;/li&gt;
  &lt;li&gt;Product purchases month-by-month&lt;/li&gt;
  &lt;li&gt;Climate changes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;많은 시계열 시스템이 빠르게 늘어나는 데이테셋을 저장하는 문제를 겪고있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;Maxwell Dayvson Da Silva, Redis Essentials&lt;/li&gt;
    &lt;li&gt;https://ko.wikipedia.org/wiki/시계열&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="database" /><category term="NoSQL" /><category term="database" /><category term="redis" /><category term="nodejs" /><category term="time-series" /><summary type="html"></summary></entry><entry><title type="html">그런 REST API로 괜찮은가.</title><link href="http://localhost:4000/backend/REST/" rel="alternate" type="text/html" title="그런 REST API로 괜찮은가." /><published>2020-11-27T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/backend/REST</id><content type="html" xml:base="http://localhost:4000/backend/REST/">&lt;h1 id=&quot;representaion-state-transfer&quot;&gt;REpresentaion State Transfer&lt;/h1&gt;

&lt;p&gt;1991년에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WWW&lt;/code&gt;이 출시된 이후 인터넷 정보를 어떻게 공유할 것인가에 대한 연구가 활발히 진행됐는데, 그 예로 가장 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;라는 프로토콜이 만들어졌다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Roy T.Fielding&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt;의 창시자이며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 프로토콜 개발에 참여했던 연구진으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 개발이후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP object model&lt;/code&gt;이란 이름의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt; 아키텍쳐를 발표했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Roy T.Fielding: “How do i improve HTTP without breaking the Web?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;rest-api&quot;&gt;REST API&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt; 아키텍쳐 스타일(제약조건의 집합)을 따르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt;는 아키텍쳐 스타일의 집합이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hyper archittecture styles&lt;/code&gt;라고도 불린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;client-server&lt;/li&gt;
  &lt;li&gt;stateless&lt;/li&gt;
  &lt;li&gt;cache&lt;/li&gt;
  &lt;li&gt;uniform interface&lt;/li&gt;
  &lt;li&gt;layered system&lt;/li&gt;
  &lt;li&gt;code-on-demand(Optional)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt; 기반에서 사용할 경우 쉽게 지켜질 수 있는 부분이나, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uniform interface&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt; 조건을 지키기 매우 까다롭다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uniform interface&lt;/code&gt;는 클라이언트 혹은 서버가 변경된다 해서 상대방까지 업데이트를 해야하는 상황을 막기위해 반드시 충족되어야 하는 조건이다.
이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적 진화&lt;/code&gt;라 하며 아래는 오늘 날 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST API&lt;/code&gt;라 불리우는 것들에게서 충족시키기 어려운 조건들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;self-descriptive messages&lt;/li&gt;
  &lt;li&gt;hypermedia as the engine of application state(HATEOAS)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 잘 지키는 플랫폼은 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;h1 id=&quot;rest가-웹의-독립적-진화에-도움을-주었나&quot;&gt;REST가 웹의 독립적 진화에 도움을 주었나?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP에 지속적으로 영향을 줌&lt;/li&gt;
  &lt;li&gt;HOST 헤더 추가&lt;/li&gt;
  &lt;li&gt;길이 제한을 다루는 방법을 명시&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;414 UIL Too Long&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP/1.1&lt;/code&gt; 명세 최신판에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt;에 대한 언급이 들어감&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;rest-api는-반드시-따라야-하나&quot;&gt;REST API는 반드시 따라야 하나?&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Roy T.Fielding: “REST emphasizes evolvability to sustain an unconrollable system. If you think you have control over the system or aren’t interested in evolvability, don’t waste your time arguing about REST”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;api를-rest-api로-구현해보자&quot;&gt;API를 REST API로 구현해보자.&lt;/h1&gt;

&lt;h2 id=&quot;웹과-http-api에-차이점&quot;&gt;웹과 HTTP API에 차이점&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;웹 페이지&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;HTTP API&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Protocol&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HTTP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HTTP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;communication&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Human - Machine&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Machine - Machine&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Media Type&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HTML&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JSON&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTML&lt;/code&gt;에 비해 불안전하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTML&lt;/code&gt;은 명세에 대해 해석 가능하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self-descriptive&lt;/code&gt;하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HATEOAS&lt;/code&gt;하다.&lt;/p&gt;

&lt;p&gt;그러면 우리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;을 통해 정보를 주고받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 환경에서 어떻게 해야 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REST&lt;/code&gt;에 대해 만족시킬 수 있을까?&lt;/p&gt;

&lt;h2 id=&quot;self-descriptive&quot;&gt;Self-descriptive&lt;/h2&gt;

&lt;h3 id=&quot;media-type을-정의한다&quot;&gt;Media type을 정의한다.&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;미디어 타입을 정의 후 문서로 정리한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IANA&lt;/code&gt;에 미디어 타입을 등록할 수 있다. 만든 문서를 미디어 타입의 명세로 등록한다.&lt;/li&gt;
  &lt;li&gt;이제 이 메세지를 보는 사람은 명세를 찾아갈 수 있으므로 이 메세지의 의미를 온전히 해석 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;profile&quot;&gt;Profile&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt;에 대한 정의를 문서로 작성한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Link&lt;/code&gt; 헤더에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile relation&lt;/code&gt;으로 해당 명세를 링크한다.&lt;/li&gt;
  &lt;li&gt;이제 메세지를 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;클라이언트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Link&lt;/code&gt; 헤더에 대한 명세를 이해해야하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content negotiation&lt;/code&gt;을 할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;hateoas&quot;&gt;HATEOAS&lt;/h2&gt;

&lt;h3 id=&quot;data에-하이퍼링크를-추가한다&quot;&gt;data에 하이퍼링크를 추가한다.&lt;/h3&gt;

&lt;p&gt;이는 링크를 표현하는 방법을 직접 정의해야하는 단점이있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JSON API&lt;/li&gt;
  &lt;li&gt;HAL&lt;/li&gt;
  &lt;li&gt;UBER&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;에서 하이퍼 링크를 표현하는 방법을 정의한 명세를 활용할 수 있지만, 기존에 내가 구현했던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;를 고쳐야하는 단점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;http-헤더로-표현&quot;&gt;HTTP 헤더로 표현&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Link&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Location&lt;/code&gt; 등의 헤더로 표현한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;https://tv.naver.com/v/2292653&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="backend" /><category term="backend" /><category term="serverless" /><summary type="html">REpresentaion State Transfer</summary></entry><entry><title type="html">Heavy-Light Decompostion(작성중)</title><link href="http://localhost:4000/algorithm/HLD/" rel="alternate" type="text/html" title="Heavy-Light Decompostion(작성중)" /><published>2020-11-23T00:00:00+09:00</published><updated>2020-11-27T05:00:00+09:00</updated><id>http://localhost:4000/algorithm/HLD</id><content type="html" xml:base="http://localhost:4000/algorithm/HLD/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;오늘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLD&lt;/code&gt;에 대해 포스팅을 해보려 한다. 문제 유형이 한정적이고 어려운 테크닉에 속하기에 포스팅할까 망설였다.(어디다 쓰는 알고리즘인데 도대체) 대회 준비를 하는 것도 아니기에 기본적인 자료구조, 알고리즘을 지향하려 했지만, 최근에는 굳이 그럴 필요 있을까 생각한다.&lt;/p&gt;

&lt;p&gt;알고리즘은 기업 코테도 있다보니 겸사겸사 시작했지만, 요즘은 하나의 논리를 배우는 거라 생각한다. 우리는 개발을 하면서 언어에 대해 항상 문법만 배우지 말을 잘하는 법을 배우진 않는다. 논리적으로 말하지 않아도 의미만 잘 전달된다면 상관없을지도 모른다. 하지만, 직업 특성상 우리는 항상 효율적인 것을 생각한다. 논리를 배우는 건 필수적이지 않지만 달변가들이 많은 논리를 알고 있는 것은 어찌보면 당연하지 않을까?&lt;/p&gt;

&lt;p&gt;서론이 길어졌다. 바로 알고리즘에 대해 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;heavy-light-decomposition&quot;&gt;Heavy-Light Decomposition&lt;/h1&gt;

&lt;p&gt;일반적인 그래프에서 정점 \(u\)에서 \(v\)로 가는 경로에 대한 문제는 풀기가 어렵고 제시할 수 있는 유형이 한정적이다. 트리에서 단순 경로는 반드시 하나 존재한다는 특성 떄문에 일반적인 경우에 비해 쉽게 접근할 수 있지만, 경로를 탐색하기 위해 트리 전체를 순회하는 결과를 야기한다. 또한, 정점이나 간선의 속성을 변경하는 작업일 경우엔 더욱이 효율적인 처리가 불가능에 가까워질 것이다.&lt;/p&gt;

&lt;p&gt;이를 해결할 수 있는 방법 중 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLD&lt;/code&gt;다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HLD&lt;/code&gt;는 트리를 정점 단위가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain&lt;/code&gt;단위로 분할하여 마치 1차원 배열의 묶음처럼 다룰 수 있게 해준다.&lt;/p&gt;

&lt;h2 id=&quot;문제-정의&quot;&gt;문제 정의&lt;/h2&gt;

&lt;p&gt;\(N\)개의 정점을 가진 트리가 있다고 하자. 이 때 임의의 두 정점에 대해 이들을 잇는 경로는 \(O(N)\)개의 간선을 가진다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heavy light decomposition&lt;/code&gt;은 트리의 간선들을 적절히 일자 경로인 “묶음”들로 잘라, 임의의 두 간선 사이 경로를 \(O(\log N)\)개의 묶음으로 표현할 수 있게 해 준다. 이것을 세그먼트 트리 등의 일차원 자료 구조와 결합함으로써, 임의의 두 정점 사이의 경로에 대한 연산을 \(O(\log^2N)\)에 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그런데 특별한 제약 조건이 없는 그래프 문제의 경우 이 모델화에 성공하면 대체로 문제가 쉬워지거나, 전형적인 알고리즘을 요구하는 문제로 바뀌게 됩니다. 오히려 제약 조건이 추가된 형태일수록 그 조건에 의해 나타나는 특성을 코어까지 활용해야 하는 어려운 문제를 자주 마주치게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1차원이라면&quot;&gt;1차원이라면?&lt;/h2&gt;

&lt;p&gt;알고스팟에서 이에 대한 기본적인 문제를 제공하지만, 나는 &lt;a href=&quot;https://www.acmicpc.net/problem/2927&quot;&gt;남극 탐험 - 2927&lt;/a&gt; 문제를 통해 예시를 풀어보려 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;http://theyearlyprophet.com/heavy-light-decomposition.html&lt;/li&gt;
    &lt;li&gt;https://www.secmem.org/blog/2019/12/12/HLD/&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="algorithm" /><category term="algorithm" /><category term="traversal" /><category term="graph" /><category term="segment_tree" /><category term="lca" /><summary type="html"></summary></entry><entry><title type="html">레디스 콜렉션</title><link href="http://localhost:4000/database/redis_01/" rel="alternate" type="text/html" title="레디스 콜렉션" /><published>2020-11-21T00:00:00+09:00</published><updated>2020-11-27T04:00:00+09:00</updated><id>http://localhost:4000/database/redis_01</id><content type="html" xml:base="http://localhost:4000/database/redis_01/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h1 id=&quot;이번-포스트에서는&quot;&gt;이번 포스트에서는..&lt;/h1&gt;

&lt;p&gt;저번 포스트에서는 기본적인 데이터 타입을 설명했다. 이번 포스트에선 한발 더 나아가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt; 데이터 타입을 살펴보려 한다.&lt;/p&gt;

&lt;p&gt;이 글은 &lt;a href=&quot;/database/redis_00&quot;&gt;레디스 기본 데이터 타입&lt;/a&gt; 포스트와 이어집니다.&lt;/p&gt;

&lt;h2 id=&quot;sets&quot;&gt;Sets&lt;/h2&gt;

&lt;p&gt;셋은 스트링과는 구분되는 순서가 없는 콜렉션이다. 중복되는 원소를 셋에 집어넣을수 없으며 내부적으로 해쉬테이블처럼 구현됐다. 이러한 이유는 최적화 때문인데, 멤버 추가, 삭제, 서치 등의 시간이 \(O(1)\)에 실행되기 때문이다.&lt;/p&gt;

&lt;p&gt;셋의 메모리 footprint?는 모든 멤버가 정수일 경우 줄일 수 있다. 멤버 최종 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-max-inset-entries&lt;/code&gt;에 의존하며 이는 챕터 4에서 추후 설명하겠다.&lt;/p&gt;

&lt;p&gt;원소 개수는 \(2^{32} -1\)이며 40억개 저장 가능하다.&lt;/p&gt;

&lt;p&gt;아래는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sets&lt;/code&gt;의 사용 사례다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 필터링: 예를들어 특정 도시에서 출발하여 다른 도시에 도착하는 지정된 항공편을 필터링 할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터 그루핑: 비슷한 제품을 본 모든 사용자를 그룹핑(아마존의 추천 시스템)&lt;/li&gt;
  &lt;li&gt;멤버쉽 체킹: 블랙리스트에 존재하는지를 확인.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sadd&quot;&gt;SADD&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SADD&lt;/code&gt;는 하나 혹은 그 이상의 멤버를 추가하기 위한 커맨드다. 만약 추가하려는 멤버가 존재할 경우 이를 기각하고, 추가된 멤버 수를 리턴한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; SADD user:max:favorite_artists &quot;Arcade Fire&quot; &quot;Arctic Monkeys&quot;
&quot;Belle &amp;amp; Sebastian&quot; &quot;Lenine&quot;
(integer) 4
127.0.0.1:6379&amp;gt; SADD user:hugo:favorite_artists &quot;Daft Punk&quot; &quot;The Kooks&quot; &quot;Arctic
Monkeys&quot;
(integer) 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sinter&quot;&gt;SINTER&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SINTER&lt;/code&gt; 커맨드는 하나 혹은 그 이상의 셋을 받고, 모든 셋에 공통적으로 존재하는 멤버를 배열로 리턴한다.&lt;/p&gt;

&lt;p&gt;아래 예제는 Hugo와 Max가 공통적으로 좋아하는 아티스트를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SINTER user:max:favorite_artists user:hugo:favorite_artists
1) &quot;Arctic Monkeys&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sdiff&quot;&gt;SDIFF&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDIFF&lt;/code&gt; 커맨드는 하나 혹은 그 이상의 셋을 받는다. 뒤에 따라오는 셋에 존재하지 않는 모든 멤버를 리턴한다. 이 커맨드는 키 네임의 순서가 중요하다. 존재하지 않는 모든 키는 빈 집합으로 간주된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SDIFF user:max:favorite_artists user:hugo:favorite_artists
1) &quot;Belle &amp;amp; Sebastian&quot;
2) &quot;Arcade Fire&quot;
3) &quot;Lenine&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 번째 예제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user:max:favorite_artists&lt;/code&gt;의 존재하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user:hugo:favorite_artists&lt;/code&gt;의 멤버를 모두 리턴한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SDIFF user:hugo:favorite_artists user:max:favorite_artists
1) &quot;Daft Punk&quot;
2) &quot;The Kooks&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sunion&quot;&gt;SUNION&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUNION&lt;/code&gt; 커맨드는 하나 혹은 그 이상의 셋을 받는다. 모든 셋의 모든 멤버를 리턴한다. 중복되는 멤버는 한 번만 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SUNION user:max:favorite_artists user:hugo:favorite_artists
1) &quot;Lenine&quot;
2) &quot;Daft Punk&quot;
3) &quot;Belle &amp;amp; Sebastian&quot;
4) &quot;Arctic Monkeys&quot;
5) &quot;Arcade Fire&quot;
6) &quot;The Kooks&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;spandmember&quot;&gt;SPANDMEMBER&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SPNADMEMBER&lt;/code&gt;는 주어진 셋에 랜덤한 멤버를 리턴한다. 셋은 순서가 없기 때문에 위치 인덱스 값으로 반환할 수 없다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SRANDMEMBER user:max:favorite_artists
&quot;Arcade Fire&quot;
127.0.0.1:6379&amp;gt; SRANDMEMBER user:max:favorite_artists
&quot;Lenine&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sismember-srem-scard-smembers&quot;&gt;SISMEMBER, SREM, SCARD, SMEMBERS&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SISMEMBER&lt;/code&gt;는 멤버가 셋 안에 존재하는지 확인한다. 존재할 경우에는 1, 아닐 경우에는 0을 리턴한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SISMEMBERS&lt;/code&gt;는 셋에 존재하는 모든 멤버를 리턴한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SREM&lt;/code&gt;은 멤버를 셋에서 삭제하고 인티저 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCARD&lt;/code&gt;는 멤버의 수를 리턴한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SISMEMBER user:max:favorite_artists &quot;Arctic Monkeys&quot;
(integer) 1
127.0.0.1:6379&amp;gt; SREM user:max:favorite_artists &quot;Arctic Monkeys&quot;
(integer) 1
127.0.0.1:6379&amp;gt; SISMEMBER user:max:favorite_artists &quot;Arctic Monkeys&quot;
(integer) 0
127.0.0.1:6379&amp;gt; SCARD user:max:favorite_artists
(integer) 3
127.0.0.1:6379&amp;gt; SMEMBERS user:max:favorite_artists
1) &quot;Belle &amp;amp; Sebastian&quot;
2) &quot;Arcade Fire&quot;
3) &quot;Lenine&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sorted-sets&quot;&gt;Sorted Sets&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;과 매우 흡사하다. 하지만 각 멤버들이 연관된 스코어를 가지고 있다. 다른 말로 하자면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;은 중복된 멤버를 가지지 않고, 스코어에의해서 정렬된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Strings&lt;/code&gt;다. 스코어는 중복될 수 있다. 이러한 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lexicographically&lt;/code&gt;하게 정렬한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt; 작업은 매우 빠르지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;의 작업보단 빠르지 않다. 추가, 삭제 갱신은 \(O(logN)\)이 걸린다. 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;은 두 개의 자료구조로 나뉘어져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skip list with hash table&lt;/code&gt; 스킵 리스트는 정렬된 원소 시퀀스를 빠르게 탐색하기 위한 자료구조다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zset-max-ziplist-entries&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zset-max-ziplist-value&lt;/code&gt;에 기반한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ziplist&lt;/code&gt; 이는 챕터 4에서 다루도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;의 사용사례다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웨이팅 리스트&lt;/li&gt;
  &lt;li&gt;온라인 게임과 같은 곳에 리더보드&lt;/li&gt;
  &lt;li&gt;자동완성 시스템&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;zadd&quot;&gt;ZADD&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZADD&lt;/code&gt;는 하나 혹은 그 이상 멤버를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;에 추가한다. 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;에 존재하는 멤버일 경우에는 요청을 무시한다. 추가된 멤버를 정수 값으로 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; ZADD leaders 100 &quot;Alice&quot;
(integer) 1
127.0.0.1:6379&amp;gt; ZADD leaders 100 &quot;Zed&quot;
(integer) 1
127.0.0.1:6379&amp;gt; ZADD leaders 102 &quot;Hugo&quot;
(integer) 1
127.0.0.1:6379&amp;gt; ZADD leaders 101 &quot;Max&quot;
(integer) 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted Set&lt;/code&gt;에 멤버는 스코어와 문자열로 추가된다. 앞에서도 설명했듯이 두가지 정렬 기준이 존재하는데, 스코어 순으로 정렬하며, 만약 스코어가 같을 경우에는 멤버의 문자열 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lexicographically&lt;/code&gt;하게 정렬한다. 앞 예제에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alice&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Zed&lt;/code&gt;가 같은 스코어를 가지기 때문에, 알파벳 순으로 정렬된다.&lt;/p&gt;

&lt;h3 id=&quot;zrange-zrevrange--withscores&quot;&gt;ZRANGE, ZREVRANGE ~ WITHSCORES&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZRANGE&lt;/code&gt;는 주어진 범위에 해당되는 멤버를 출력하며, 오름차순으로 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZREVRANGE&lt;/code&gt;는 주어진 범위에 해당되는 멤버를 출력하며, 내림차순으로 출력한다.&lt;/p&gt;

&lt;p&gt;위 두 커맨드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WITHSCORES&lt;/code&gt;를 옵션 파라미터로 줄 수 있으며, 스코어를 같이 출력하게 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; ZREVRANGE leaders 0 -1 WITHSCORES
1) &quot;Hugo&quot;
2) &quot;102&quot;
3) &quot;Max&quot;
4) &quot;101&quot;
5) &quot;Zed&quot;
6) &quot;100&quot;
7) &quot;Alice&quot;
8) &quot;100&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; ZREVRANGE leaders 0 -1
1) &quot;Hugo&quot;
2) &quot;Max&quot;
3) &quot;Zed&quot;
4) &quot;Alice&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;zrem&quot;&gt;ZREM&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZREM&lt;/code&gt;은 멤버를 지운다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; ZREM leaders &quot;Hugo&quot;
(integer) 1
127.0.0.1:6379&amp;gt; ZREVRANGE leaders 0 -1
1) &quot;Max&quot;
2) &quot;Zed&quot;
3) &quot;Alice&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;zscore-zrank-zrevrank&quot;&gt;ZSCORE, ZRANK, ZREVRANK&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSCORE&lt;/code&gt;는 특정 멤버에 스코어를 반환한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZRANK&lt;/code&gt;는 특정 멤버에 랭크(인덱스)를 반환한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZREVRANK&lt;/code&gt; 는 특정 멤버에 랭크를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;high to low&lt;/code&gt; 방향에서 인덱스를 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; ZSCORE leaders &quot;Max&quot;
&quot;101&quot;
127.0.0.1:6379&amp;gt; ZRANK leaders &quot;Max&quot;
(integer) 2
127.0.0.1:6379&amp;gt; ZREVRANK leaders &quot;Max&quot;
(integer) 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bitmap&quot;&gt;Bitmap&lt;/h2&gt;
&lt;p&gt;비트맵이 실제 데이터 타입은 아니고, 스트링이다. 스트링에 비트 오퍼레이션을 진행하기 위해 만들어진 데이터 타입이라 볼 수 있다. 레디스에선 이를 조작할 수 있는 커맨드들을 제공하기에 데이터 타입으로 취급한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;은 0과 1을 저장할 수 있는 비트 시퀀스이다. 레디스 공식 문서에서 비트맵에 인덱스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt;으로 불린다.&lt;/p&gt;

&lt;p&gt;비트맵이 메모리를 어떻게 효율적으로 사용하는지 알기위해선 Set과 비교해볼 필요가있다.&lt;/p&gt;

&lt;h3 id=&quot;comparison-scenario&quot;&gt;Comparison Scenario&lt;/h3&gt;

&lt;p&gt;만약 5백만명의 사용자가 존재하고, 하루에 2백만명 정도의 사용자가 웹사이트에 접속한다고 가정하자. 이때 사용자 아이디는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4byte&lt;/code&gt; 정수값으로 표현된다.&lt;/p&gt;

&lt;p&gt;웹사이트에 당일 접속한 모든 유저의 아이디를 저장하는 기능을 구현한다하면, (비트맵에선 오프셋이 유저의 아이디를 매핑할 것이다) 이러한 상황에서 두 자료구조는 아래와 같은 구현 스펙이 결정된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Redis Key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Data type&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Amount of bits per user&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Stored users&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Total memory&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;visits:2015-01-01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Bitmap&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 bit&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5 million&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 * 5000000 bits = 625kB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;visits:2015-01-01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Set&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 bit&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2 million&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 * 2000000 bits = 8MB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;최악의 상황에서도 비트맵은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;보다 괜찮은 메모리 효율을 보여주고 있다. 하지만 그렇다고해서 항상 비트맵이 효율적이라고 단정지을 순 없다. 아래 테이블을 보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Redis Key&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Data type&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Amount of bits per user&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Stored users&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Total memory&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;visits:2015-01-01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Bitmap&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 bit&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5 million&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 * 5000000 bits = 625kB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;visits:2015-01-01&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Set&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 bit&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 * 100 bits = 3.125KB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;비트맵은 실시간 분석에 사용하기 적합한 자료구조이다. 예를들어, 사용자 X가 Y를 얼마나 행했는가에 대한 질문 혹은 얼마나 많은 유저가 Y라는 이벤트를 행했는지 확인할 수있다. 아래는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;에 대한 사용 예시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;얼마나 많은 사람이 오늘 이 블로그 포스트를 봤는가?&lt;/li&gt;
  &lt;li&gt;특정 유저 1이 오늘 이 블로그를 읽었는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;setbit&quot;&gt;SETBIT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SETBIT&lt;/code&gt;는 특정 비트맵에 있는 오프셋을 설정한다. 1과 0만을 값으로 받으며, 만약 존재하지 않을 경우 생성한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; SETBIT visits:2015-01-01 10 1
(integer) 0
127.0.0.1:6379&amp;gt; SETBIT visits:2015-01-01 15 1
(integer) 0
127.0.0.1:6379&amp;gt; SETBIT visits:2015-01-02 10 1
(integer) 0
127.0.0.1:6379&amp;gt; SETBIT visits:2015-01-02 11 1
(integer) 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;getbit&quot;&gt;GETBIT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GETBIT&lt;/code&gt;는 특정 비트맵에 있는 오프셋을 가져온다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; GETBIT visits:2015-01-01 10
(integer) 1
127.0.0.1:6379&amp;gt; GETBIT visits:2015-01-02 15
(integer) 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bitcount&quot;&gt;BITCOUNT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BITCOUNT&lt;/code&gt;는 특정 비트맵에 1로 설정된 오프셋의 개수를 반환한다. 현재 예제에서는 당일 날 접속한 사용자가 몇명인지 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; BITCOUNT visits:2015-01-01
(integer) 2
127.0.0.1:6379&amp;gt; BITCOUNT visits:2015-01-02
(integer) 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bittop&quot;&gt;BITTOP&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BITOP&lt;/code&gt;는 비트 연산을 수행하며 이에 대한 결과값을 저장할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destination key&lt;/code&gt;가 필요하다. 비트 오퍼레이션에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XOR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt; 등이 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; BITOP OR total_users visits:2015-01-01 visits:2015-01-02
(integer) 2
127.0.0.1:6379&amp;gt; BITCOUNT total_users
(integer) 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;hyperloglogs&quot;&gt;HYperloglogs&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt; 또한 실제 데이터타입은 아니다. 개념적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unique element&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cardinality&lt;/code&gt; 근사값을 제공하는 데에 효과적인 알고리즘이다.&lt;/p&gt;

&lt;p&gt;\(O(1)\), 상수시간안에 이를 해결하며, 메모리 사용량도 매우 적기 때문에 효과적이다. 실제 데이터타입은 아니지만, 레디스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt;를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cardinality&lt;/code&gt;를 계산 하기위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;을 조작하는 커맨드를 제공한다.&lt;/p&gt;

&lt;p&gt;하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt; 사용할 때 알아둬야 할 것은 이 알고리즘은 확률적 알고리즘으로써 정확도가 100퍼센트는 아닌, 근사값을 예측하는 알고리즘이라는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Redis&lt;/code&gt;에서는 기본적으로 0.81퍼센트의 오차가 있다고 말한다.&lt;/p&gt;

&lt;p&gt;알고리즘에 대한 설명은 &lt;a href=&quot;http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf&quot;&gt;HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm&lt;/a&gt; 에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;아래는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HyperLogLog&lt;/code&gt;에 사용 예시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹사이트를 방문한 특정 유저의 수.&lt;/li&gt;
  &lt;li&gt;특정 시간 혹은 날짜에 나의 사이트에서 검색된 용어 개수&lt;/li&gt;
  &lt;li&gt;해쉬태크 개수&lt;/li&gt;
  &lt;li&gt;이 포스트에서 사용된 구별가능한 단어 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;countiong-unique-users---hyperloglog-vs-set&quot;&gt;Countiong unique users - Hyperloglog vs Set&lt;/h3&gt;

&lt;p&gt;시간당 평균 10만명에 사용자가 접속한다고 하자. 각각의 사용자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UUID(universally unique identifier)&lt;/code&gt;와 같은 32바이트 스트링(ex:  de305d54-75b4-431b-adb2-eb6b9e546014)으로 특정된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Data type&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Memory in an hour&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Memory in a day&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Memory in a month&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HyperLogLog&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12 kb&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12 kB * 24 = 288 kB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;288 kB * 30 = 8.4 MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Set&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 bytes * 100000 = 3.2 MB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3.2 MB * 24 = 76.8 MB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;76.8 MB * 30 = 2.25 GB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HyperLogLog&lt;/code&gt;는 시간당 특정 사용자가 접속한지 확인하기 위해 저장매체의 용량이 12kb 밖에 안된다.&lt;/p&gt;

&lt;h3 id=&quot;pfadd&quot;&gt;PFADD&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFADD&lt;/code&gt;는 하나 혹은 그 이상의 스트링을 입력받으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cardinality&lt;/code&gt;가 변경되었을 경우 1 아닐경우 0을 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; PFADD visits:2015-01-01 &quot;carl&quot; &quot;max&quot; &quot;hugo&quot; &quot;arthur&quot;
(integer) 1
127.0.0.1:6379&amp;gt; PFADD visits:2015-01-01 &quot;max&quot; &quot;hugo&quot;
(integer) 0
127.0.0.1:6379&amp;gt; PFADD visits:2015-01-02 &quot;max&quot; &quot;kc&quot; &quot;hugo&quot; &quot;renata&quot;
(integer) 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pfcount&quot;&gt;PFCOUNT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFCOUNT&lt;/code&gt;는 하나 혹은 그 이상의 키를 받으며, 인자가 하나일 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;approximate cardinality&lt;/code&gt;를 반환한다. 키가 여러 개일 경우 총 합을 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PFCOUNT visits:2015-01-01
(integer) 4
127.0.0.1:6379&amp;gt; PFCOUNT visits:2015-01-02
(integer) 4
127.0.0.1:6379&amp;gt; PFCOUNT visits:2015-01-01 visits:2015-01-02
(integer) 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pfmerge&quot;&gt;PFMERGE&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PFMERGE&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destination key&lt;/code&gt;를 필요로 하며, 하나 혹은 그 이상의 키를 인자로 받아야 한다. 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt;를 모두 저장한 값을 리턴한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; PFMERGE visits:total visits:2015-01-01 visits:2015-01-02
OK
127.0.0.1:6379&amp;gt; PFCOUNT visits:total
(integer) 6

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;Maxwell Dayvson Da Silva, Redis Essentials&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="database" /><category term="NoSQL" /><category term="database" /><category term="redis" /><category term="nodejs" /><summary type="html"></summary></entry><entry><title type="html">FaaS, BaaS</title><link href="http://localhost:4000/backend/FaaS_BaaS/" rel="alternate" type="text/html" title="FaaS, BaaS" /><published>2020-11-20T00:00:00+09:00</published><updated>2020-11-20T04:00:00+09:00</updated><id>http://localhost:4000/backend/FaaS_BaaS</id><content type="html" xml:base="http://localhost:4000/backend/FaaS_BaaS/">&lt;p&gt;서버리스 컴퓨팅에 대해 정리하다가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaaS&lt;/code&gt;에 대한 언급이 잦아 정리해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;function-as-a-service&quot;&gt;Function as a Service&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS Lambda&lt;/code&gt;가 대표적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;의 예시다. 아래는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS Lambda&lt;/code&gt;의 공식 홈페이지 설명을 가져와봤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWS Lambda lets you run code without provisioning or managing servers. … With Lambda, you can run code for virtually any type of application or backend service ) - all with zero administration. Just upload your code and Lambda takes care of everything required to run and scale  your code with high availability. You can set up your code to automatically trigger from other AWS services or call it directly from any web or mobile app.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt; 근본적으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long-lived&lt;/code&gt; 서버 어플리케이션 혹은 서버 시스템을 관리 없이 실행 가능한 백엔드 코드이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long-lived&lt;/code&gt; 서버는 어플리케이션 컨테이너나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PaaS&lt;/code&gt;와 같은 모던 아키텍쳐 트렌드와 비교할 때 중요한 차이점이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;는 특정 프레임워크나 라이브러리의 코딩을 필요로 하지 않는다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS Lambda&lt;/code&gt; 함수는 Javascript, Python, Go, 모든 JVM 언어(Java, Clojure, Scala 등) 또는 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;first class&quot;&lt;/code&gt; 를 구현할 수 있다.
심지어 람다 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployment artifact&lt;/code&gt;와 함께 제공되는 번들로 다른 프로세스를 실행할 수 있다. 즉, 모든 언어를 사용할 수 있는 것이다.
&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt; 함수는 특히 상태 및 실행 시간에 관항 경우 구조적인 제약이 있다.
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포시에는 기존 시스템 구조와 매우 다른데, 구동시킬 서버 어플리케이션이 존재하지 않기 때문이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt; 환경에서는 코드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt; 제공자에게 업로드하고, 제공자가 리소스 프로비저닝, VM 인스턴스화, 프로세스 관리 등에 필요한 모든 작업을 수행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수평 스케일링은 완전히 자동적이고 탄력적이며, 제공자에 의해 관리된다. 만약 시스템이 100개의 리퀘스트를 병렬처리 해야 한다하자 어떤 추가적인 작업없이 해당 요청을 처리할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compute container&lt;/code&gt;는 일시적으로 생성되는 함수이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt; 제공자가 요구되는 시간에 생성하고 삭제한다. 가장 중요한 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;를 통해 벤더가 모든 기본 리소스 프로비저닝 및 할당을 처리한다는 점이다. 즉, 사용자가 클러스터나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VM&lt;/code&gt;을 관리할 필요가 전혀 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;내 함수는 제공자에게 정의된 전형적인 이벤트 타입의 함수다. 아마존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S3&lt;/code&gt;업데이트, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheduled tasks&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;messages bus&lt;/code&gt; 등이 이에 대한 예시다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대부분의 제공자는 인바운드 HTTP 리퀘스트에 대한 응답으로 함수가 트리거 되는 것을 허용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS&lt;/code&gt;에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 게이트웨이를 사용하여 이를 가능하게 한다. 함수는 플랫폼에서 제공된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;를 통해 직접적으로 포함될 수 있지만, 이는 자주 사용되지는 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;mobile-backend-as-a-service&quot;&gt;Mobile Backend as a Service&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaaS&lt;/code&gt;로도 많이 알려진 이름이다. 웹앱과 모바일앱 개발자에게 어플리케이션에서 노출되는 백엔드 클라우드 스토리지 및 API에 어플리케이션을 연결하는 동시에 사용자 관리, 푸시 알림, 소셜 네트워크 서비스의 통합 등의 기능을 제공하는 모델이다. 이는 커스텀 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDKs&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APIs&lt;/code&gt;를 통해 제공될 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;웹과 모바일 앱은 운영을 위해  알림 서비스, 소셜네트워크 통합, 클라우드 저장소 등 백엔드의 비슷한 기능을 필요로한다. 각각의 앱과 상호작용 하기 위한 API를 가지며 개발자에게 많은 시간을 소모하게 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaaS&lt;/code&gt; 제공자는 프론트엔드와 클라우드 베이스의 백엔드를 API와 SDK를 통해 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;백엔드 데이터를 일관성 있게 관리할 수 있는 방법을 제공한다는 것은 개발자가 앱에서 접근해야할 각 서비스에 대해 재개발 하지 않아도 되는 것을 의미한다. 이는 시간과 비용을 모두 절약할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클라우드 컴퓨팅 비지니스 모델인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SaaS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IaaS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PaaS&lt;/code&gt;와 비슷해 보이지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaaS&lt;/code&gt;는 자사 앱을 클라우드 서비스에 연결하는 통일된 수단을 제공함으로써 웹 및 모바일 앱 개발자의 클라우드 컴퓨팅 요구를 구체적으로 해결한다는 차별점이 존재한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;https://martinfowler.com/articles/serverless.html#unpacking-faas&lt;/li&gt;
    &lt;li&gt;https://en.wikipedia.org/wiki/Mobile_backend_as_a_service&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="backend" /><category term="backend" /><category term="serverless" /><category term="FaaS" /><summary type="html">서버리스 컴퓨팅에 대해 정리하다가 FaaS와 BaaS에 대한 언급이 잦아 정리해보려고 한다.</summary></entry><entry><title type="html">Serverless</title><link href="http://localhost:4000/backend/Serverless/" rel="alternate" type="text/html" title="Serverless" /><published>2020-11-20T00:00:00+09:00</published><updated>2020-11-20T04:00:00+09:00</updated><id>http://localhost:4000/backend/Serverless</id><content type="html" xml:base="http://localhost:4000/backend/Serverless/">&lt;p&gt;이 글은 https://martinfowler.com/bliki/Serverless.html 번역을 기반으로 작성된 포스트입니다!&lt;/p&gt;

&lt;h1 id=&quot;serverless-란&quot;&gt;Serverless 란&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serverless&lt;/code&gt; 아키텍처는 기존과 다른 인터넷 기반 서버개발 프로세스이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;third-party services&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client-side logic&lt;/code&gt;, 호스팅 원격 프로시져 콜의 조합에만 의존한다.(Instead they rely solely on a combination of third-party services, client-side logic, and service hosted remote procedure calls &lt;a href=&quot;/backend/FaaS_BaaS&quot;&gt;(Faas)&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/serverless-archittectures.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serverless&lt;/code&gt; 어플리케이션은 전통적으로 서버가 처리하던 작업을 수행하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;third party services&lt;/code&gt;를 광범위하게 사용한다. 이러한 서비스는 아마존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Azure&lt;/code&gt;와 같이 상호 운용되는 서비스의 풍부한 생태계가 될 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Firebase&lt;/code&gt;같은 턴키 기능 셋을 제공하는 단일 서비스일 수도 있다.&lt;/p&gt;

&lt;p&gt;이 서비스에서 제공되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abstraction&lt;/code&gt;은 인프라(메세지 큐, 데이터베이스, edge caching) 또는 더 높은 수준에 (federated identity, role and capability managemnet, seach) 등이 될 수 있다.&lt;/p&gt;

&lt;p&gt;범용 서버 기반 웹 어플리케이션에서 가장 중요한 것 중 하나는 request-response 사이클을 제어하는 것이다. 서버사이드에 컨트롤러는 입력을 처리하고 적절한 어플리케이션 작업을 포함하며, 동적인 리스폰스를 생성한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;third-party services&lt;/code&gt;로부터 어플리케이션 동작이 함께 짜여진 서버리스 어플리케이션에서 클라이언트 사이드 컨트롤러와 동적 콘텐츠 생성은 서버 사이트 컨트롤러로 대체한다. 수많은 자바스크립트 어플리케이션과 모바일 어플리케이션은 API 호출과 동적인 콘텐츠 생성을 위한 클라이언트 사이드 UI 프레임워크를 사용함으로써 다양한 서비스 간의 상호작용을 조정한다.&lt;/p&gt;

&lt;p&gt;서버 기반 웹 어플리케이션의 가장 중요한 부분은 컨트롤러와 인프라 사이에 발생하는 작업이다;(비지니스 로직) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long-lived server&lt;/code&gt;는 이 로직을 구현하는 코드를 호스트하고 어플리케이션 활성 상태를 유지하는 한 필요한 처리를 수행한다. 서버리스 어플리케이션에서, 커스텀 코드 컴포넌트는 단일 HTTP request/response 사이클의 타임라인보다 더욱 짧고, 가까운 라이프 사이클을 가진다. 코드는 리퀘스트가 도착했을 때 실행되며, 이를 처리하고 종료되는 즉시 휴먼상태가 된다. 이러한 코드는 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS Lambda&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Azure Function&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Cloud Function&lt;/code&gt;등 코드 생명주기를 관리하고 스캐일링을 돕는 환경에서 사용할 수 있다. 이러한 스타일의 소프트웨어를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FaaS&lt;/code&gt;라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;더 좋은 서버리스 아키텍쳐에 대해 읽고 싶다면 &lt;a href=&quot;https://martinfowler.com/articles/serverless.html&quot;&gt;이 링크&lt;/a&gt;를 읽어보는 것도 좋다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;https://martinfowler.com/bliki/Serverless.html&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="backend" /><category term="backend" /><category term="serverless" /><summary type="html">이 글은 https://martinfowler.com/bliki/Serverless.html 번역을 기반으로 작성된 포스트입니다!</summary></entry><entry><title type="html">레디스 기본 데이터 타입</title><link href="http://localhost:4000/database/redis_00/" rel="alternate" type="text/html" title="레디스 기본 데이터 타입" /><published>2020-11-18T00:00:00+09:00</published><updated>2020-11-16T04:00:00+09:00</updated><id>http://localhost:4000/database/redis_00</id><content type="html" xml:base="http://localhost:4000/database/redis_00/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h1 id=&quot;redis&quot;&gt;Redis?&lt;/h1&gt;

&lt;p&gt;길게 소개하자면 한도 끝도 없고, 나 말고도 필력 좋은 블로그들이 더 잘 소개했을 것 같기에 간단하게만 중점만 짚어 소개하자면,&lt;/p&gt;

&lt;p&gt;레디스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;In-Memory Database&lt;/code&gt;로서 고가용성인 메모리에 저장하고 조회한다. 기존 관계형 데이터베이스 앞에 캐싱 시스템으로 이용하기 적합한 것으로 알려져있다. 오픈소스인만큼 다양한 서비스에서 사용되고 있으며, 앞으로 계속해서 중요한 역할을 할 것같아 책에 예제와 함께 내용을 정리해보려 한다.&lt;/p&gt;

&lt;p&gt;이번 포스트에서는 레디스의 자료형에 대해 알아보겠다.&lt;/p&gt;

&lt;p&gt;모든 내용은 책 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maxwell Dayvson Da Silva, Redis Essentials&lt;/code&gt;의 기반하고 있다.&lt;/p&gt;

&lt;h1 id=&quot;레디스-데이터-타입&quot;&gt;레디스 데이터 타입&lt;/h1&gt;

&lt;p&gt;레디스의 특징이라면 바로 다양한 자료구조를 지원한다는 점인데, 또 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;In-Memory Database&lt;/code&gt;인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Memcached&lt;/code&gt;와 차이가 두드러진다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/redis-collection.png&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레디스는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sorted&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt; 를 제공했고, 버전이 올라가면서 현재는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Geospatial Index&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hyperloglog&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 등의 자료형도 지원하고 있다.
다양한 데이터 타입을 지원하는만큼 때에 따라 다양한 사용방법을 익히고 적용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;string&quot;&gt;String&lt;/h2&gt;

&lt;p&gt;스트링 자료구조는 가장 보편적인 데이터 타입이다. 다목적 사용이 가능하며 여러 커맨드를 구비하고 있다.
텍스트 문자열과 정수, 비트맵 등 다양한 타입을 사용할 수 있다. 또한 어떤 형식의 데이터도 될 수 있으며, 512MB를 초과하지 않는 선에서 데이터 타입을 저장 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cache mechanism: 텍스트나 바이너리 데이터를 캐시 가능하며 API 응답, HTML 페이지의 이미지 혹은 비디오일 수 있다. 간단한 캐싱은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MGET&lt;/code&gt;을 이용하여 가능하다.&lt;/li&gt;
  &lt;li&gt;Cache with automatic expiration: 자동 만료 키를 사용하여 캐싱을 효과적으로 이용할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SETEX&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXPIRE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXPIREAT&lt;/code&gt;와 같은 커맨드를 사용하며, 데이터베이스 실행 시간이 상당히 길며 캐싱을 같이해야 하는 경우 매우 유용할 수 있다.&lt;/li&gt;
  &lt;li&gt;Counting: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBY&lt;/code&gt;를 통해 사용가능하다. 카운터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page view&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;video view&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;like&lt;/code&gt;에 이용될 수 있으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECRBY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRFLOATBY&lt;/code&gt; 등도 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mest-mget&quot;&gt;MEST MGET&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEST&lt;/code&gt;은 다중 키 설정을 도와준다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MGET&lt;/code&gt;은 다중 키 획득을 도와준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; MSET first &quot;First Key value&quot; second &quot;Second Key value&quot;
OK
127.0.0.1:6379&amp;gt; MGET first second
1) &quot;First Key value&quot;
2) &quot;Second Key value&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;expire-ttl&quot;&gt;EXPIRE TTL&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXPIRE&lt;/code&gt;는 키에 만료 시간을 설정할 수 있다. 만료시간이 자나면 자동으로 삭제되며, 만료시간이 성공적으로 설정되면 1, 아니면 0을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TTL&lt;/code&gt;은 아래와 같은 값을 반환한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;양수: 만료까지 남은 시간을 출력한다.&lt;/li&gt;
  &lt;li&gt;-2: 키가 존재하지 않거나 만료되었을 경우 출력한다.&lt;/li&gt;
  &lt;li&gt;-1: 키가 만료시간이 설정되지 않았을 경우 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; SET current_chapter &quot;Chapter 1&quot;
OK
127.0.0.1:6379&amp;gt; EXPIRE current_chapter 10
(integer) 1
127.0.0.1:6379&amp;gt; GET current_chapter
&quot;Chapter 1&quot;
127.0.0.1:6379&amp;gt; TTL current_chapter
(integer) 3
127.0.0.1:6379&amp;gt; TTL current_chapter
(integer) -2
127.0.0.1:6379&amp;gt; GET current_chapter
(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;incr-incrby-incrbybloadt&quot;&gt;INCR INCRBY INCRBYBLOADT&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCR&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBY&lt;/code&gt;는 비슷한 기능을 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCR&lt;/code&gt;은 키값을 1 올린 후 값을 리턴한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBY&lt;/code&gt;는 주어진 정수 값을 토대로 키 값을 올린 후 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECR&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DECRBY&lt;/code&gt;는 위 두 커맨드와 상반되게 키 값을 빼는 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBYFLOAT&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; 값을 더할 수 있다.
위 세 커맨드 모드 양수 음수 모두 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; SET counter 100
OK
127.0.0.1:6379&amp;gt; INCR counter
(integer) 101
127.0.0.1:6379&amp;gt; INCRBY counter 5
(integer) 106
127.0.0.1:6379&amp;gt; DECR counter
(integer) 105
127.0.0.1:6379&amp;gt; DECRBY counter 100
(integer) 5
127.0.0.1:6379&amp;gt; GET counter
&quot;5&quot;
127.0.0.1:6379&amp;gt; INCRBYFLOAT counter 2.4
&quot;7.4&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 보여진 커맨드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ATOMIC&lt;/code&gt;하다 즉, 하나의 오퍼레이션으로 취급한다는 것인데 이는 두 명의 서로 다른 클라이언트가 같은 시간의 같은 실행 명렁어를 통해 같은 값을 얻을 수 없다는 것이다.&lt;/p&gt;

&lt;p&gt;예를들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter&lt;/code&gt; 키가 1이라면 서로 다른 클라이언트 A와 B가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCR&lt;/code&gt;을 동시에 입력했을 때 A가 2 B가 3을 받게 될것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Redis is single threaded, which means that it always executes one
command at a time. Sometimes, commands are mentioned as atomic,
which means that a race condition will never happen when multiple
clients try to perform operations on the same key at the same time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;nodejs-voting-system&quot;&gt;Node.js voting system&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;redis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;upVote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;article:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:votes&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;downVote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;article:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:votes&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;decr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;showResults&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;headlineKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;article:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:headline&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;voteKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;article:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:votes&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;headlineKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;voteKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;replies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;The article &quot;&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;replies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&quot; has&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;replies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
 &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;votes&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MGET&lt;/code&gt;을 이용하여 키 배열과 콜백함수를 전달한다. 만약 키 값이 없다면 null을 리턴할 것이다.
&lt;br /&gt;
익명함수 파라미터인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replies&lt;/code&gt;는 두 개의 밸류를 가진다. 각각 주어진 키 배열 순서대로 매핑된 값이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt; 클라이언트는 반드시 비동기적&lt;/p&gt;

&lt;h2 id=&quot;lists&quot;&gt;Lists&lt;/h2&gt;
&lt;p&gt;리스트는 레디스에서 매우 유동적인 데이터 타입이다. 스택, 큐와 같은 기능 또한 구현할 수 있으며, 많은 시스템들이 작업 큐를 사용하기 위해 리스트를 이용한다. 이는 동시성을 제공하는 시스템에서 리스트의 동작이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt;하기 때문이다.&lt;/p&gt;

&lt;p&gt;리스트에는 블록킹 커맨드가 존재한다. 만약 클라이언트가 블록킹 커맨드를 빈 리스트에 실행한다면 클라이언트는 새로운 아이템이 들어오기까지 기다린다.(blocking)&lt;/p&gt;

&lt;p&gt;레디스 리스트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linked List&lt;/code&gt;로 구현되어 있기 때문에 맨앞과 맨뒤에 아이템을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insertion&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deletion&lt;/code&gt;하는 과정이 \(O(1)\)만에 가능하다.
특정 아이템을 액세스 하는데에는 \(O(N)\)이 걸리며, 마찬가지로 맨 앞과 맨 뒤는 상수시간안에 가능하다.&lt;/p&gt;

&lt;p&gt;리스트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list-max-ziplist-entries&lt;/code&gt;값보다 작은 원소 개수와 ` list-max-ziplist-value` 값보다 작은 원소 값을 가진다면 최적화와 인코딩이 가능하다. 이는 추후 4챕터에서 알아보도록 하자.&lt;/p&gt;

&lt;p&gt;실제 사용 예시&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Event Queue: 이미 많은 툴에서 사용 중이다.&lt;/li&gt;
  &lt;li&gt;Storing most recent user posts: 트위터는 최근 유저의 트윗을 리스트에 저장하여 이를 구현했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;list-examples-with-redis-cli&quot;&gt;List examples with redis-cli&lt;/h3&gt;

&lt;p&gt;링크드 리스트인만큼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt;에 데이터 삽입 삭제가 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LPUSH&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt;에 새로운 값을 넣는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RPUSH&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt;에 새로운 값을 삽입한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ redis-cli
127.0.0.1:6379&amp;gt; LPUSH books &quot;Clean Code&quot;
(integer) 1
127.0.0.1:6379&amp;gt; RPUSH books &quot;Code Complete&quot;
(integer) 2
127.0.0.1:6379&amp;gt; LPUSH books &quot;Peopleware&quot;
(integer) 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLEN&lt;/code&gt;: 리스트의 길이를 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LINDEX&lt;/code&gt;: 주어진 인덱스에 저장된 값을 반환한다. 리스트를 수정하지 않는 커맨드다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인덱스는 항상 왼쪽에서 오른쪽으로 진행된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;negative-index&lt;/code&gt; 또한 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; LLEN books
(integer) 3
127.0.0.1:6379&amp;gt; LINDEX books 1
&quot;Clean Code&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LRANGE&lt;/code&gt;: 주어진 인덱스 범위 내에 값을 모두 리턴한다. 앞에서 언급했듯이 음수 인덱스가 가능하기에 아래와 같은 예제가 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; LRANGE books 0 1
1) &quot;Peopleware&quot;
2) &quot;Clean Code&quot;
127.0.0.1:6379&amp;gt; LRANGE books 0 -1
1) &quot;Peopleware&quot;
2) &quot;Clean Code&quot;
3) &quot;Code Complete&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LPOP&lt;/code&gt;: 가장 처음 원소를 리스트에서 제거하면서 동시에 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RPOP&lt;/code&gt;: 가장 마지막 원소를 리스트에서 제거하면서 동시에 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 둘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RINDEX&lt;/code&gt;와 다르게 리스트를 수정하는 커맨드다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; LPOP books
&quot;Peopleware&quot;
127.0.0.1:6379&amp;gt; RPOP books
&quot;Code Complete&quot;
127.0.0.1:6379&amp;gt; LRANGE books 0 -1
1) &quot;Clean Code&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;hashes&quot;&gt;Hashes&lt;/h2&gt;

&lt;p&gt;해쉬는 오브젝트를 저장하기에 적절한 저장구조이다. 필드를 값에 대입할 수 있으며, 메모리 사용과 데이터 엑세스에 매우 최적화 돼있다.
해쉬는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String to String&lt;/code&gt; 매핑 구조이다.&lt;/p&gt;

&lt;p&gt;우리는 위에서 투표 시스템 구현을 통해 일종의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sematic&lt;/code&gt;한 해쉬를 구현했다. 하지만, 해쉬를 사용하는 직접적인 이유는 메모리 최적화 때문이다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-max-ziplist-entries&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash-max-ziplist-value&lt;/code&gt;를 통해 사용가능하며, 챕터 4에서 자세히 알아보겠다.&lt;/p&gt;

&lt;p&gt;해쉬는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hash table&lt;/code&gt; 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ziplist&lt;/code&gt;가 될 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ziplist&lt;/code&gt;는 메모리 최적화된 양방향 링크드 리스트다. 정수는 캐릭터 시퀀스 대신 실제 정수가 저장된다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ziplist&lt;/code&gt;는 최적화에 불구하고 룩업에는 일정한 시간이 걸린다. 반면에 해시 테이블은 상수 시간에 탐색이 가능하지만 메모리 최적화는 되어있지 않다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Instagram had to back-reference 300 million media IDs to user IDs,
and they decided to benchmark a Redis prototype using Strings
and Hashes. The String solution used one key per media ID and
around 21 GB of memory. The Hash solution used around 5 GB with
some configuration tweaks&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;using-hashes-with-redis-cli&quot;&gt;Using Hashes with redis-cli&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSET&lt;/code&gt;: 필드에 주어진 키에 대해 값을 설정한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSET key field value&lt;/code&gt;와 같은 문법으로 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMSET&lt;/code&gt;: 여러 필드 값을 키에 설정할 수 있다. 스페이스로 구분한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 둘은 필드 값이 존재하지 않을 경우 생성하고 있을 경우 덮어쓰기를 진행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HINCRBY&lt;/code&gt;: 주어진 인티저 값을 필드에 더한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HINCRBYFLOAT&lt;/code&gt;:  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBY&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INCRBYFLOAT&lt;/code&gt; 비슷하게 동작한다. 아래 코드에서 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt; HSET movie &quot;title&quot; &quot;The Godfather&quot;
(integer) 1
127.0.0.1:6379&amp;gt; HMSET movie &quot;year&quot; 1972 &quot;rating&quot; 9.2 &quot;watchers&quot; 10000000
OK
127.0.0.1:6379&amp;gt; HINCRBY movie &quot;watchers&quot; 3
(integer) 10000003
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HGET&lt;/code&gt;: 해쉬에서 필드를 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMGET&lt;/code&gt;: 필드들을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; HGET movie &quot;title&quot;
&quot;The Godfather&quot;
127.0.0.1:6379&amp;gt; HMGET movie &quot;title&quot; &quot;watchers&quot;
1) &quot;The Godfather&quot;
2) &quot;10000003&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HDEL&lt;/code&gt;: 해쉬에서 필드를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; HDEL movie &quot;watchers&quot;
(integer) 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HGETALL&lt;/code&gt;: 모든 필드/밸류 페어를 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; HGETALL movie
1) &quot;title&quot;
2) &quot;The Godfather&quot;
3) &quot;year&quot;
4) &quot;1972&quot;
5) &quot;rating&quot;
6) &quot;9.2&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSCAN&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HGETALL&lt;/code&gt;은 해쉬가 많은 필드를 포함할 경우 매우 큰 메모리를 사용하여 레디스 성능의 영향을 미칠 수 있다. 이럴 경우 대책으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSCAN&lt;/code&gt;이 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSCAN&lt;/code&gt;은 모든필드를 리턴하지 않고 커서와 주어진 개수만큼 출력하게 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;font size=&quot;6&quot;&gt;Refernce&lt;/font&gt;
  &lt;ul&gt;
    &lt;li&gt;https://medium.com/garimoo/개발자를-위한-레디스-튜토리얼-01-92aaa24ca8cc&lt;/li&gt;
    &lt;li&gt;Maxwell Dayvson Da Silva, Redis Essentials&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>조원빈</name></author><category term="database" /><category term="NoSQL" /><category term="database" /><category term="redis" /><category term="nodejs" /><summary type="html"></summary></entry></feed>